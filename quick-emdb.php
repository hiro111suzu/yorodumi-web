<?php
//. init
$main_json = $json;

_add_lang( 'quick-emdb' );
_add_trep( 'quick-emdb' );

_add_fn(   'quick-emdb' );
_add_url(  'quick-emdb' );
//_add_unit( 'quick-emdb' );

//$ftpdir = _url( 'ftpdir' );

define( 'URL_HTTP_DL', _url( 'emdb_arc_http', ID ) );
define( 'MOV_EX'	 , $main_id->ex_mov() );
define( 'MOLDATA_EX' , $main_id->ex_polygon() );

define( 'TERM_REC_MET', _met_pop([
	'e' => 'electron microscopy' ,
	't' => 'electron tomography' ,
	'a' => 'subtomogram averaging' ,
	's' => 'single particle reconstruction' ,
	'i' => 'single particle reconstruction' ,
	'h' => 'helical reconstruction' ,
	'2' => 'electron crystallography' 
][ $main_id->add()->met ], 'm' ) ); //- metではicosがない、英語で返す必要がある

define( 'TERM_CRYOEM', $main_id->add()->cryo
	? _met_pop( 'cryo EM', 'm' )
	: null
);

define( 'TERM_STAIN', $main_id->add()->stained
	? _met_pop( 'negative staining', 'm' )
	: ''
);

$dn_media = DN_EMDB_MED . "/$id";

_define_term( <<<EOD
TERM_IMG_UNDER_PREP
	Images and movies for this entry are currently under preparation
	このエントリの画像及び動画は現在準備中です
TERM_CUBIC_LATTICE
	generated in cubic-lattice coordinate
	これらの図は立方格子座標系で作成されたものです
TERM_SPIDER_IMG
	Images are generated by _1_.
	画像は _1_ により作成
TERM_FSC_DESC
	FSC plot (resolution estimation)
	FSC曲線 (解像度の算出)
TERM_SEGMENTATION
	Segmentation
	セグメンテーションマップ
TERM_ADDITIONAL_MAP
	Additional map
	追加マップ
TERM_HALFMAP
	Half map
	ハーフマップ
EOD
);

//- 単位文字列の変換、v3対応
define ( 'UNIT_REP', [
	'full' => [
		's' => 'sec.' ,
		'nanometer' => 'nm' ,
		'percentage' => '%' ,
		'deg' => '&deg;'
	],
	'rep' => [
		'^2' => '<sup>2</sup>' ,
		'^3' => '<sup>3</sup>' ,
		'Å' => '&Aring;' ,
	],
]);

//. 追加データ
$mov_info = $main_id->movjson(); //- ムービー情報
$map_info = $main_id->mapjson(); //- マップ情報

_simple()->time( 'emdb init' );

//. supmol-tree
$items = [];
$has_m = [];
$has_s = [];
$name = [];
$type = [];
//.. supmol
foreach ( (array)$main_json->sample->supramolecule as $c ) {
	$i = 's'. $c->supramolecule_id;
	$name[ $i ] = $c->name;
	$type[ $i ] = $c->supmol_type;
	if ( ! $name[0] )
		$name[0] = $c->name;
	foreach ( _branch( $c, 'macromolecule_list->macromolecule[*]->macromolecule_id' ) as $m ) {
		if ( ! $m ) continue;
		$has_m[ $i ][] = "m$m";
	}
	if ( $c->parent && $c->parent != $c->supramolecule_id ) {
		$has_s[ 's'. $c->parent ][] = $i;
	} else {
		$has_s[ 'e' ][] = $i;
	}
}

//.. macmol
$num_mac = 0;
foreach ( (array)$main_json->sample->macromolecule as $c ) {
	$i = 'm'. $c->macromolecule_id;
	$name[ $i ] = $c->name;
	$type[ $i ] = $c->macmol_type;
	$has_m[ 'e' ][] = $i;
	++ $num_mac;
}

//.. make
$done = []; //- 重複防止
$sup_mol_list = _supmol_list( 'e' );
$done = [];
$sup_mol_list_abst = 
	( $name[0] == $main_json->sample->name
		? ''
		: $main_json->sample->name. ' !=  ' . $name[0] . _p( $main_json->sample->name )
	)
	//- macmolが多いときは、概要のみ
	. _supmol_list( 'e', 10 < $num_mac )
;

function _supmol_list( $mol_id, $flg_abst = false ) {
	global $has_m, $has_s, $done, $type;
	$items = [];
	foreach ( (array)$has_s[ $mol_id ] as $i ) {
		$items[] = _type_name( $i ). _supmol_list( $i, $flg_abst );
	}
	$count = [];
	foreach ( (array)$has_m[ $mol_id ] as $i ) {
		if ( $done[ $i ] ) continue;
		$done[ $i ] = true;
		if ( $flg_abst ) {
			++ $count[ $type[ $i ] ?: 'other' ];
		} else {
			$items[] = _type_name( $i );
		}
	}
//	_testinfo( $count, $mol_id );
	foreach ( $count as $k => $v ) {
		$items[] = _kv([ $k => " x $v". _ej( ' types', '種' )]);
	}
	return $items ? _ul( $items ) : '';
}
function _type_name( $mol_id ) {
	global $name, $type;
	return _kv([ $type[ $mol_id ] =>
		$type[ $mol_id ] == 'virus'
			? _quick_taxo( $name[ $mol_id ] )
			: $name[ $mol_id ]. _obj('wikipe')->pop_xx( $name[ $mol_id ] )
	]);
}

//. basic
//.. sample name
$s = _x( $main_json->sample->name );
define( 'SAMPLE_NAME', _ezsqlite([
	'dbname' => 'taxoid' ,
	'where'	 =>	[ 'name', $s ] ,
	'select' => 'id' ,
]) ? _quick_taxo( $s ) : _f( $s ) );

//.. 生物種
//- taxo
$src_items = [];
foreach ( _branch_multi( $main_json,
	'sample->supramolecule[*]->natural_source[0]->organism' ,
	'sample->macromolecule[*]->natural_source[0]->organism' ,
	'sample->supramolecule[*]->sci_species_name' ,
) as $o ) {
	$src_items[] =_quick_taxo( $o );
}

//.. citation
$citation = new cls_citation();
//- primary
if ( ! $citation->pubmed_json( $main_id->add()->pmid ) ) {
	$citation->emdb_json(
		$main_json->crossreferences->primary_citation->journal_citation
	);
}

//- secondary
$cnt = 1;
foreach ( (array)$main_json->crossreferences->secondary_citation as $j ) {
	if ( ! $citation->pubmed_json( $j->journal_citation->ref_PUBMED ) ) {
		$j->non_journal_citation
			? $citation->emdb_non_journal( $j->non_journal_citation, $cnt )
			: $citation->emdb_json( $j->journal_citation, $cnt )
		;
	}
	++ $cnt;
}

//.. history
//... supersession
$date = [];
$history = [];
$c = $main_json->admin->obsolete_list->entry;
if ( $c ) {
	$history[] = [
		'date'	=> $date[] = $c->date ,
		'event'	=> 'Supersession' ,
		'ID'	=> _ab( [ 'quick', $c->entry ],  $c->entry ) ,
		'show'	=> true
	];
}

//... date
foreach ( $main_json->admin->key_dates as $k => $v ) {
	$history[] = [
		'date'	=> $date[] = $v ,
		'event'	=> $k ,
		'show'	=> in_array( $k, [ 'deposition', 'map_release' ] )
	];
}

//... current
$c = $main_json->admin->current_status;
if ( $c ) {
	$history[] = [
		'date'		=> $c->date ?: max( $date ),
		'event'		=> 'current status' ,
		'processing site' => $c->processing_site  ,
		'Status'	=> _trep( $c->code ) ,
		'show'		=> true ,
	];
}

//.. funding
$funding = [];
$flags = [];
$num = 0;
$country_jname = _subdata( 'e2j', 'country' );
foreach ( (array)$main_json->admin->grant_support->grant_reference as $c ) {
	$f = ''
		. _country_flag( $c->country )
		. _ej(
			$c->country ,
			$country_jname[ $c->country ] ?: $c->country
		)
	;
	$funding[] = [
		$c->funding_body ,
		$c->code ,
		$f
	];
	++ $num;
	$flags[] = $f;
}

if ( $funding ) {
	$flags[] = $num. _ej( ' items', '件' );
	$funding = _imp( _uniqfilt( $flags ) ) . ' '
		. _more( _table_toph(
			[ 'Organization', 'Grant number', 'Country' ],
			$funding,
			[ 'opt' => '.smaller' ] 
		))
	;
}
unset( $flags, $country_jname );

//.. f&h annotation mng用
$fh_annot = '';
if ( TEST ) {
	define( 'EMDB_UNP_TSV', _tsv_load( DN_EDIT. '/unpid_emdb_annot.tsv' ) );
	$pmid = $main_id->add()->pmid;
	if ( EMDB_UNP_TSV[ $pmid ] ) {
		$fh_annot = _span( '.red', ''
			. EMDB_UNP_TSV[ $pmid ]
			. ' <= '
			. _ab( 'pap.php?id='. $pmid, 'PMID:'. $pmid )
		);
	} else if ( _flg_emdb_unp( ID ) ) {
		$fh_annot = _input_emdb_unp( ID, $pmid );
	}
}
_simple()->time( 'basic-prep' );

//.. output
function _f( $in ){
	return $in. _obj('wikipe')->pop_xx( $in );
}

$o_data->basicinfo([
	'flg_vis'        => MOV_EX ,
	'flg_link'       => true ,
	'js_open_viewer' => MOV_EX ? "_pmov.open('$did')" : '',
	'add_txt'		 =>
		$main_id->ex_map() &&
		! file_exists( _fn( 'emdb_snap', ID, 's1' ) ) &&
		! file_exists( _fn( 'emdb_snap', ID, 's2' ) )
			? _p( LABEL_YM_ANNOT. TERM_IMG_UNDER_PREP )
			: ''
	, 
])
->lev1ar([
	'Title'				=> _f( $main_json->admin->title ) ,
	'Map data'			=> _f( $main_json->map->annotation_details ). _hdiv_focus( 'map' ),
	'Sample'				=> $sup_mol_list_abst. _hdiv_focus( 'sample' ),
	'Keywords'			=> _keywords( $main_json->admin->keywords ) ,
	'func_homology'		=> _func_homology(),
	'Biological species' => _imp2( _uniqfilt( $src_items ) ) ,

	'Method'			=> _imp2([ TERM_REC_MET, TERM_CRYOEM, TERM_STAIN,
		_ifnn( $main_id->add()->reso, _quick_kv([ 'Resolution' => '\1 &Aring' ]) )
	]) . _hdiv_focus( 'experimental' )
	,
	'Authors'			=> _authlist( $main_id->add()->author ),
	'Funding support' 	=> $funding ,
	'Citation'			=> $citation->output() ,
	'History'			=> _history_table( $history ) ,
	'F&H annot'			=> $fh_annot ,
	'EMN category'		=> _emn_categ() ,
])
->test_item([
	_ab([ 'json', DID ], 'jsonview' ) ,
	_ab([ 'jsonview', 'emdb_add.'. ID ], 'add-json' ) ,
	_ab([ 'jsonview', 'pap_emdb.'. ID ], 'pap-json' ) ,
	_ab([ 'jsonview', 'emdb_met.'. ID ], 'met-json' ) ,
	_ab([ 'disp', 'emdb_kw.'. ID ], 'search terms' ) ,
	_ab([ 'dir_emdb_med', ID ], _fa( 'folder' ) . 'media dir' ),
	_ab([ '_mng-dir', 'fn' => 'emdb_ftp|'. ID ], 'FTP dir on fs3' )
])
;

//.. end
_simple()->time( 'basic' );

unset( $citation, $history, $compo, $funding );

//. visualization
//.. ムービー、ビューア
_viewer();

//.. sup-fig
//$sup_images = '';
$out = '';
//- imagesディレクトリの中
foreach ( glob( "$dn_media/images/*.thumb.jpg" ) as $tfn ) {
	$ffn = strtr( $tfn, [ '.thumb.jpg' => '' ] ); //- フルサイズの画像
	$fn = basename( $ffn );
	$out .= _icap([
		'img' => $tfn ,  //- thumb
		'cap' => strlen( $fn ) < 15 ? $fn : substr( $fn, 0, 12 ) . '...'  ,
		'url' => _instr( '.tif', $fn ) ? "$ffn.jpg" : $ffn
	]); 
}

//- EMDBの画像
if ( ! $out && _url_file_ex( 'emdb_fig', ID ) )
	$out = _icap([
		'url' => _url( 'emdb_fig_gif', ID ) ,
		'img' => _url( 'emdb_fig', ID ),
		'cap' => 'EMDB figure' ,
	]);

//- 'other'の画像
foreach ( glob( "$dn_media/other/*.thumb.jpg" ) as $tfn ) {
	$ffn = strtr( $tfn, [ '.thumb.jpg' => '' ] ); //- 元画像フルパス
	$fn = basename( $ffn ); //- 元画像ファイル名
	//- tif画像か、jpg画像か
	$out .= _icap([
		'url' =>_instr( '.tif', $fn ) ? "$ffn.jpg" : $ffn ,
		'img' => $tfn ,  //- thumb
		'cap' => ( strlen( $fn ) < 15 ) ? $fn : substr( $fn, 0, 12 ) . '...'
	]); 
}
$o_data->lev1( 'Supplemental images', $out );

//. ダウンロードとリンク
$o_data->lev1title( 'downlink', true );

//.. EMDB archive
$arch = new cls_archive( ID );
//- 順番固定
$files = $main_id->ex_map()
	? [ 'map' => [], 'header' => [] ]
	: [ 'header' => [] ]
;

$url_disp = TEST
	? 'disp.php?path=/data/yorodumi/fdata/emdb-mirror/structures/EMD-'. ID
	: URL_HTTP_DL
;
foreach ( (array)_emn_json( 'filelist', DID ) as $type => $c ) {
	 foreach ( $c as $a ) {
		extract( (array)$a ); //- $name , $size
		$files[ $type ]['dl'][] = _a(
			URL_HTTP_DL. "/$type/$name",
			IC_DL. $name,
			"download:$name"
		);
		if ( _instr( '.xml', $name ) ) {
			$files[ $type ]['disp'][] = _ab(
				"$url_disp/$type/$name",
				_fa('file-text-o'). _l('Display') 
			);
		}
		$files[ $type ]['size'][] = _format_bytes( $size );
	}
}
$f = _url( 'ftpdir', ID );
$files['archive_dir'] = [
	'dl' => [ _ab( URL_HTTP_DL, IC_L. URL_HTTP_DL ), _ab( $f, IC_L. $f ) ] ,
	'size' => [ 'HTTPS', 'FTP' ]
];

$hdiv_focus = [
	'map'	=> _hdiv_focus('map') ,
	'masks'	=> _hdiv_focus('supplemental') ,
	'other'	=> _hdiv_focus('supplemental') ,
];
foreach ( $files as $type => $c ) {
	$dl = $disp = $size = [];
	extract( $c );
	$o_data->lev2( "filedesc_$type" ?: $type, implode( TD, [
		implode( BR, $dl ) ,
		implode( BR, $size ) ,
		implode( BR, $disp ) ?: $hdiv_focus[ $type ] ,
		in_array( $type, [ 'map', 'header', 'masks', 'fsc' ] )
			? _doc_pop( "file_emdb_$type" )
			: null
		,
	]) );
}
$o_data->end2( 'EMDB archive' );

//.. validation report EMDB
if ( is_dir( _fn( TESTSV ? 'dn_valrep_emdb_fs3' : 'dn_valrep_emdb_mainsv', $id ) ) ) {
	foreach ([ 'sum', 'full', 'xml', 'cif', 'dir', ] as $type )
		_archive_tr( $arch->get( "valrep_emdb_$type" ), [ 'no_file_no_link' => true ] );
}
$o_data->end2( 'Validation report' );

//.. 関連構造データ
$id_list = [];
foreach ([ 'emdb', 'pdb' ] as $db ) {
	foreach ( (array)$main_json->crossreferences->{ $db. '_reference' } as $c ) {
		$text = [];
		foreach ( $c->relationship as $k => $v ) {
			if ( $k != 'other' )
				$text[] = $k;
			if ( ! in_array( $v, [ 'other EM volume', 'unknown' ] ) )
				$text[] = $v;
		}
		$text[] = $c->details;
		$i = $db == 'emdb'
			? 'emdb-'. _numonly( $c->emdb_id )
			: 'pdb-'. $c->pdb_id
		;
		$id_list[ $i ][ 'txt' ] = _imp( $text );
	}
}

( new cls_related([
	'is_em' => true ,
	'id_list' => $id_list ,
]) )
->set_omokage( 'e'. ID )
->set_similar([[ 'ida' => 'e'. ID ]])
->set_others()
->end();

//.. リンク
//	->lev3( '#notag',  )
//	->lev3( '#notag',  )
//... keyword for mom
$kw = [];
foreach ( (array)_json_load2([ 'pubmed', $main_id->add()->pmid ])->kw as $c ) {
	$kw[] = $c->name;
}

//- categ
$kw[] = _categ2momkw();
$kw[] = $main_json->sample->name;
foreach ( (array)$main_json->sample->supramolecule as $c ) {
	$kw[] = $c->name;
	$kw[] = $c->sci_species_name;
}

//... output
$o_data
	->lev2( 'EMDB pages', _imp2([
		_ab([ 'emdb_ent_ebi' , $id ], IC_L. 'EMDB (EBI/PDBe)' ) ,
		_ab([ 'emdb_ent_emdr', $id ], IC_L. 'EMDataResource' ),
	]))
	->lev2( TERM_REL_MOM, _mom_items( $kw ) )

	->end2( 'Links' )
;
//unset( $emp_json, $emp_link );
//_similar();
_simple()->time( 'dl&link' );

//. map data
$o_data->lev1title( 'Map' );
$map = $main_json->map;

//.. file
$file = $map->file;
$o_data->lev1( 'File', $main_id->ex_map()
	? [
		'#notag' => _ab( _url( 'dl-map', ID ), IC_DL. _l( 'Download' ) ) ,
		'File'		=> $map->file ,
		'format'	=> $map->format ,
		'size' 		=> _format_bytes( $map->size_kbytes * 1000 ) ,
		'type'		=> $map->data_type ,
//		'label'		=> $map->label ,
	]
	: _trep( $main_json->admin->current_status->code )
);

//.. annotation
$o_data->lev1( 'Annotation', $main_json->map->annotation_details );

//.. projection / slices
if ( file_exists( "$dn_media/mapi/proj0.jpg" ) ) {

	//... スライスjs用パラメータ
	$slicejs = 1; //- javascript 実行する

	//- 「長い」と判断されたかどうか (「長い構造」のスライスは大きさが違う)
	$x = $map_info->NC;
	$y = $map_info->NR;
	$z = $map_info->NS;
	$a = [ $x, $y, $z ];
	rsort( $a );

	//- 長い構造？
	$long = $a[0] > $a[1] && $a[0] > $a[2];

	//- 薄い？
	if ( $a[2] * 10 < $a[0] && $a[1] * 10 < $a[0] ) $long = false;
	if ( $a[0] > 1000 ) $long = 0;

	if ( $long ) {
		$xr = $x / $a[0] / 6;
		$yr = $y / $a[0] / 6;
		$zr = $z / $a[0] / 6;
		$xa = [ 's' => 0, '_' =>  0, 'a' => 0.5 - $xr, 'b' => 0.5, 'c' => 0.5 + $xr ];
		$ya = [ 's' => 1, '_' =>  1, 'a' => 0.5 - $yr, 'b' => 0.5, 'c' => 0.5 + $yr ];
		$za = [ 's' => 0, '_' =>  0, 'a' => 0.5 - $zr, 'b' => 0.5, 'c' => 0.5 + $zr ];
		
		//- 0:横線 , 1:縦線
		$lv2r[0][ 'x' ] = $za;
		$lv2r[1][ 'x' ] = $ya;

		$lv2r[0][ 'y' ] = $za;
		$lv2r[1][ 'y' ] = $xa;

		$lv2r[0][ 'z' ] = $ya;
		$lv2r[1][ 'z' ] = $xa;
	} else {
		$lv2r[0][ 'x' ] = $lv2r[0][ 'y' ] =
		$lv2r[1][ 'y' ] = $lv2r[1][ 'z' ] =
			[ 's' => 0, '_' =>  0, 'a' => 1/3, 'b'=> 0.5, 'c' => 2/3 ];
		$lv2r[1][ 'x' ] = $lv2r[0][ 'z' ] =
			[ 's' => 1, '_' =>  1, 'a' => 1/3, 'b'=> 0.5, 'c' => 2/3 ];
	}
	_simple()->jsvar([ 'lv2r' => $lv2r ]);

	//- スライスラインを出力
	foreach ( [ 
		'slc_za', 'slc_zb', 'slc_zc',
		'slc_ya', 'slc_yb', 'slc_yc',
		'slc_xa', 'slc_xb', 'slc_xc',
		'slc_z_', 'slc_y_', 'slc_x_',
		'slc_xs', 'slc_ys', 'slc_zs'
	] as $n ) {
		_simple()->hidden .= _div( "#l_$n | .l_slc" );
	}

	//... output
	$n2xyz = [ 1 => 'X', 2 => 'Y', 3 => 'Z' ];
	$xyz_s = $n2xyz[ $map_info->MAPS ];
	$xyz_r = $n2xyz[ $map_info->MAPR ];
	$xyz_c = $n2xyz[ $map_info->MAPC ];
	$s = "input| type:range| autocomplete:off";

	$o_data->lev1( 'Projections & slices', ''
		. _btn( "!$('#slcimg_ctrl').toggle('fast')" ,
			_fa( 'sliders blue' ). _l( 'Image control' )
		)
		. _div( '#slcimg_ctrl', ''
			. _t( 'h2', _l( 'Image control' )
				. _btn( ".closebtn| !$('#slcimg_ctrl').hide('fast')", 'X' )
			)
			. _table_2col([
				'Size' => _e(
					"$s| value:100| min:100| max:500| step:10|"
					. '#sld_size| oninput:_slcimg.sldsize(this)'
				) ,
				'Brightness' => _e( 
					"$s| value:100| min:0| max:400| step:5|"
					. '#sld_brgt| oninput:_slcimg.filter()'
				) ,
				'Contrast' => _e(
					"$s| value:100| min:0| max:800| step:5| #sld_cont|"
					. 'oninput:_slcimg.filter()'
				) ,
				'Others' => ''
					. _chkbox( _l( 'Invert' ) ,
						'#chkb_invt| onchange:_slcimg.filter()| autocomplete:off', false )
					. _chkbox( _l( 'Y flip' ) ,
						'#chkb_yflip| onchange:_slcimg.yflip()| autocomplete:off', false )
					. ' '
					. _btn( '!_slcimg.reset()', _l( 'Reset' ) )
			])
		)

		//- テーブル
		. _t( 'table|#pstable', ''
			. TR
			. TH . _l( 'Axes' )
			. TH . _img( 'img/ori-z.gif' ) . "$xyz_s (Sec.)"
			. TH . _img( 'img/ori-y.gif' ) . "$xyz_r (Row.)"
			. TH . _img( 'img/ori-x.gif' ) . "$xyz_c (Col.)"
			. _e( 'tr | .small' )
			. TD
			. _pstable_top( $map_info, 'NS', $xyz_s )
			. _pstable_top( $map_info, 'NR', $xyz_r )
			. _pstable_top( $map_info, 'NC', $xyz_c )
			. ( file_exists( "$dn_media/mapi/surf_x.jpg" )
				? _pstable_row( 'ori-sf', 'Surface', 'surf_z', 'surf_y', 'surf_x' )
				: ''  
			)
			. _pstable_row( 'ori-pj', 'Projections', 'proj0', 'proj2', 'proj3' )
			. _pstable_row( 'slc-1', 'Slices (1/3)', 'slc_za', 'slc_ya', 'slc_xa' )
			. _pstable_row( 'slc-2', 'Slices (1/2)', 'slc_zb', 'slc_yb', 'slc_xb' )
			. _pstable_row( 'slc-3', 'Slices (2/3)', 'slc_zc', 'slc_yc', 'slc_xc' )
		)
		. _p( _term_rep( TERM_SPIDER_IMG, _met_pop( 'Spider', 's' ) ) )
		. (
			//- 直行座標じゃないマップ
			$map->cell->alpha != 90 || $map->cell->beta != 90 ||
			$map->cell->gamma != 90 ||
			$map->spacing->x != $map->spacing->y || $map->spacing->x != $map->spacing->z 
			? _p( '.red', TERM_CUBIC_LATTICE )
			: ''
		)
	);
}
_simple()->css( <<<EOD
//- プロジェクションとかのテーブル
#pstable, #pstable td, #pstable th {
	border: none; margin: 0; padding: 0; background: white; }
#pstable td, #pstable th {
	width: auto; height: auto; vertical-align: middle; text-align: center; }

//- スライスホバー
.slc { border: 2px solid transparent; }
.slc:hover { border: 2px solid #a00; }
.l_slc { display: none; position: absolute; border: 1px solid #a00;
	box-shadow: 0 0 3px #ffffff; z-index: 300; background: rgba(255,255,255,0.2); }

#slcimg_ctrl {
	display: none;
	position:fixed; left:1em; top:1em;
	background: rgba(255,255,255,0.5); box-shadow: 1px 1px 10px #777;
	z-index: 200;
	padding: 0;
}
#slcimg_ctrl input[type=range] { width: 200px;
}
#slcimg_ctrl h2 {
	font-syze: medium;
	background: $col_dark; color: white;
	margin: 0; padding: 0.2em; 
}
EOD
);

//.. voxel size
//- xml info
$xx = round( $map->pixel_spacing->x , 5 );
$xy = round( $map->pixel_spacing->y , 5 );
$xz = round( $map->pixel_spacing->z , 5 );

//- ccp4 header info
if ( $map_info ) {
	$hx =round( $map_info->{'APIX X'} , 5 );
	$hy =round( $map_info->{'APIX Y'} , 5 );
	$hz =round( $map_info->{'APIX Z'} , 5 );
}

//- Movie info
if ( $mov_info ) {
	$mx = _ifnn( round( $mov_info->{1}->{'apix x'}, 5 ), '\1', $hx );
	$my = _ifnn( round( $mov_info->{1}->{'apix y'}, 5 ), '\1', $hy );
	$mz = _ifnn( round( $mov_info->{1}->{'apix z'}, 5 ), '\1', $hz );
}

function _near( $a, $b ) {
	if ( $a == '' || $b == '' ) return true;
	if ( max( [ $a/$b, $b/$a ] ) < 1.1 ) return true;
}

//- 一致？
$o_data->lev1( 'Voxel size',

	_near( $xx, $hx ) && _near( $xx, $mx ) &&
	_near( $xy, $hy ) && _near( $xy, $my ) &&
	_near( $xz, $hz ) && _near( $xz, $mz )

	//- だいたい同じ
	? ( $xx == $xy && $xx == $xz
		? [ 'X=Y=Z' => "$xx &Aring;" ]
		: [ 'X' => "$xx &Aring;", 'Y' => "$xy &Aring;", 'Z' => "$xz &Aring;" ]
	)

	//- 無視できない違い
	: _table_2col([
		''						=> [ 'X', 'Y', 'Z' ] ,
		'EMDB info.'			=> [ $xx, $xy, $xz ],
		'CCP4 map header'		=> [ $hx, $hy, $hz ],
		'EM Navigator Movie #1' => $mx ? [ $mx, $my, $mz ] : '' 
	], [
		'opt'		=> '.itable | st:color:red',
		'multi_col'	=> true,
		'topth'		=> true 
	])
);

//.. density
//- 表面
$surf = [];
$num = 1;
foreach ( (array)$map->contour as $c ) {
	$n = ( $c->primary ? 'primary' : '' ) ?: _sharp( $num );
	$k = $c->source ? "By ". $c->source : $n;
	if ( $surf[ $k ] )
		$k .= _kakko( $n );
	$surf[ $k ] = $c->level;
	++ $num;
}

if ( $mov_info && $mov_info->{1}->mode != 'solid' )
	$surf['Movie #1'] = round( $mov_info->{1}->threshold, 7 );

$d = "$dn_media/mapi";
$ms = $map->statistics;

$o_data->lev1( 'Density',

	//- ヒストグラム
	( file_exists( "$d/hists.png" ) ? ''
		. _icap([
			'url' => [ 'histogram_l', ID ],
			'img' => [ 'histogram_s', ID ],
			'cap' => 'Histogram' ,
		])
		. _icap([
			'url' => [ 'histogram_log_l', ID ],
			'img' => [ 'histogram_log_s', ID ],
			'cap' => 'Histogram (log scale)' ,
		])
	: '')

	//- 表面レベルの表
	. _table_2col([
		'Contour Level'	=> _quick_kv( $surf ) ,
		'Minimum - Maximum' => $ms->minimum .' - '. $ms->maximum ,
		'Average (Standard dev.)'
			=> $ms->average . _kakko( $ms->std == 0 ? '-' : '&plusmn;'. $ms->std )
		],
		[ 'opt' => '.clboth' ]
	) 
);

//.. symmetry
//... symmetry
$sym = [];
foreach ( $map->symmetry as $k => $v ) {
	if ( is_string( $v ) )
		$sym[ $k ] = $v;
	else foreach( $v as $k2 => $v2 ) {
		$sym[ $k2 ] = $v2;
	}
}
$o_data->lev1( 'Symmetry', $sym );

//.. details

/*
if ( $map->symmetry->space_group ) {
	$sym['Space Group Number'] = $map->symmetry->space_group;
} else if ( {
$out =  TR.TH. _ej( 'Space Group Number', '空間群番号' ) .TD. $map->symmetry->space_group;
*/

//... ジオメトリ
$geo = [ 'Axis order' => [
	$map->axis_order->fast ,
	$map->axis_order->medium ,
	$map->axis_order->slow ,
]];

foreach( [ 'origin', 'dimensions', 'limit' ] as $n ) {
	$r = $c = $s = '';
	foreach ( (array)$map->$n as $k => $v ) {
		if ( _instr( 'row', $k ) ) $r = $v;
		if ( _instr( 'col', $k ) ) $c = $v;
		if ( _instr( 'sec', $k ) ) $s = $v;
	}
	if ( $r.$c.$s )
		$geo[ $n ] = [ $r, $c,  $s ];
}
$geo[ 'spacing' ] = [
	$map->spacing->x ,
	$map->spacing->y ,
	$map->spacing->z ,
];

//... cell

$a = $map->cell->a;
$b = $map->cell->b;
$c = $map->cell->c;
$d = $map->cell->alpha;
$e = $map->cell->beta;
$f = $map->cell->gamma;

$out = _p( '.bld', 'EMDB XML:' ). _table_2col([
	'Map geometry' => _table_2col( $geo, [ 'multi_col'=> true] )
	,
	_ej( 'Cell', 'セル'  ) => ''
		. ( $a == $b && $b == $c
			? _kv([ 'A=B=C' => "$a &Aring;" ])
			: _kv([
				'A' => "$a &Aring;" ,
				'B' => "$b &Aring;" ,
				'C' => "$c &Aring;"
			])
		)
		. BR
		. ( $d == $e && $e == $f
			? _kv([ '&alpha;=&beta;=&gamma;' => "$f &deg;" ])
			: _kv([
				'&alpha;' => "$d &deg;" ,
				'&beta;'  => "$e &deg;" ,
				'&gamma;' => "$f &deg;"
			])
		)
	,
]);


//... ccp4 header info
if ( $mov_info != '' && $main_id->status()->mov1 ) {
	$s = TR.TH. 'mode<td colspan=3>'. [ 
		0 => 'envelope stored as signed bytes (from -128 lowest to 127 highest)' ,
		1 => 'Image stored as Integer*27' ,
		2 => 'Image stored as Reals' ,
		3 => 'Transform stored as Complex Integer*2' ,
		4 => 'Transform stored as Complex Reals'
	][ $map_info->MODE ];

	foreach ( [
		'&Aring;/pix. X/Y/Z' => 'APIX X/APIX Y/APIX Z',
		'M x/y/z'			=> 'MX/MY/MZ',
		'origin x/y/z'		=> 'XORIGIN/YORIGIN/ZORIGIN',
		'length x/y/z'		=> 'X length/Y length/Z length',
		'&alpha;/&beta;/&gamma;' => 'Alpha/Beta/Gamma',
		'start NX/NY/NZ'	=> 'NXSTART/NYSTART/NZSTART',
		'NX/NY/NZ'			=> 'NX/NY/NZ',
		'MAP C/R/S'			=> 'MAPC/MAPR/MAPS',
		'start NC/NR/NS'	=> 'NCSTART/NRSTART/NSSTART',
		'NC/NR/NS'			=> 'NC/NR/NS',
		'D min/max/mean'	=> 'DMIN/DMAX/DMEAN'
	] as $t => $n ) {
		$a = [];
		foreach ( explode( '/', $n ) as $n1 )
			$a[] = $map_info->$n1;
		if ( ! implode( '', $a ) ) continue;
		$s .= TR.TH. $t .TD. implode( TD, $a );
	}
	$out .= _p( '.bld', _l('CCP4 map header' ) . ': ' )
		. _t( 'table', $s )
	;
}
$o_data->lev1( 'Details', _more( $out ) );

//. Supplement
$o_data->lev1title( 'Supplemental data', true );
$_out = '';
_simple()->time( 'map' );

//.. filename => annotation
$map_annot = [];
foreach ([
	TERM_SEGMENTATION => 
		'interpretation->segmentation_list->segmentation[*]->mask_details' ,
	TERM_ADDITIONAL_MAP =>
		'interpretation->additional_map_list->additional_map' ,
	TERM_HALFMAP =>
		'interpretation->half_map_list->half_map' ,
] as $type => $branch ) {
	foreach ( _branch( $main_json, $branch ) as $j ) {
		if ( ! $j ) continue;
		$map_annot[ $j->file ] = [
			'full' => $j->annotation_details ,
			'type' => $type ,
		];
	}
}

//_testinfo( $map_annot );
$num = [];
foreach ( $map_annot as $key => $val ) {
	$type = $val['type'];
	$map_annot[ $key ]['short'] = strlen( $val['full'] ) < 70
		? "$type: ". ( $val['full'] ?: '#'. ( ++ $num[ $val['type'] ] ) )
		: "$type: ". implode( ' ', array_slice( explode( ' ', $val['full'] ), 0, 8 ) ). '...'
	;
	if ( _instr( 'additional_1.map', $key ) ) {
		$key1 = strtr( $key, [ 'additional_1.map' => 'additional.map' ] );
		if ( ! $map_annot[ $key1 ] )
			$map_annot[ $key1 ] = $map_annot[ $key ];
	}
}
//_testinfo( $map_annot );

//.. mask
//- ファイル
$mskjson = _json_load( "$dn_media/masks/list.json" );
$addnum = $mskjson[ 0 ]  || $mskjson[ 1 ] ? 0 : 1;

$done = [];
$i = 0;
foreach ( (array)$main_json->supplement->mask as $c1 ) {
	$f = $c1->file;
	$annot = $map_annot[ $f->name ];
	$o_data->lev2( 'Annotation', $annot['full'] );
	$o_data->lev2( 'File' ,
		_a( URL_HTTP_DL. "/masks/{$f->name}",
			IC_DL. $f->name. _kakko( "{$f->type} file in {$f->format} format, {$f->sizeKb} KB" )
		)
	);

	//- 画像
	if ( $mskjson[ $i + $addnum ] != '' )
		_prjslc( "$dn_media/masks/" . ( $i + $addnum ) );

	//- 文字情報
	foreach( $c1 as $n2=>$c2 ) {
		if ( $n2 == 'file' ) continue;

		//- 文字列
		if ( ! is_object( $c2 ) ) {
			$o_data->lev2( $n2, $c2 );
			continue;
		}
	}

	$done[ $i ] = 1;
	$i ++;
	$o_data->end2( $annot['short'] ?: "Mask|#$i" );
}

//- 書いていないのがあれば追加
foreach ( (array)$mskjson as $i => $fn ) {
	if ( $done[ $i ] ) continue;
	$annot = $map_annot[ $fn ];
	$o_data->lev2( 'Annotation', $annot['full'] );
	$o_data->lev2( 'File', _a( URL_HTTP_DL. "/masks/$fn", IC_DL . $fn ) );
	_prjslc( "$dn_media/masks/$i" );
	$o_data->end2( $annot['short'] ?: "Mask|#$i" );
}

//.. figure
//- 今のところ、EMDB-XML情報には、ファイル名しか書いてない、間違っているのも多い
//- なので使わない、実際にファイルがあるモノのみ、そのファイルを表示

//.. images
//if ( $sup_images != '' )
//	$_out .= _index( 2, 'Images' ) . _tr( 'Images', $sup_images );

//.. fsc
//- EMDB-XMLのFSCタグに、ファイル名以外の情報を持つデータは、存在しないので
//if ( file_exists( "$dn_media/fsc/fscs.jpg" ) ) {
//	$_out .= _index( 2, 'FSC' )
//		. _tr( 'FSC', _ab( "$dn_media/fsc/fscl.png", _timg( "$dn_media/fsc/fscs.jpg" ) ) );
//}

//.. other
$dn_other = "$dn_media/other";
$out = '';

if ( is_dir( $dn_other ) ) {
	$scandir = scandir( $dn_other );

	//- map
//	$o_map = [];
	foreach ( $scandir as $dn ) {
		if ( ! is_dir( "$dn_other/$dn" ) ) continue;
		if ( ! _instr( '.map.d', $dn ) && ! _instr( '.mrc.d', $dn ) ) continue;
		$fn = strtr( $dn, [ '.map.d' => '.map', '.mrc.d' => '.mrc' ] );
		$annot = $map_annot[ $fn ] ?: $map_annot[ "$fn.gz" ];
		$o_data->lev2( 'File', _a( URL_HTTP_DL. "/other/$fn.gz", $fn ) );
		$o_data->lev2( 'Annotation', $annot['full'] );
		_prjslc( "$dn_other/$dn" );
		$o_data->end2( $annot 
			? $annot['short']
			: _l( 'Supplemental map' ) . ": $fn"
		);
	}
/*
		$o_map[] = [
			'title'	=> $annot 
				? $annot['short']
				: _l( 'Supplemental map' ) . ": $fn"
			,
			'file'	=> _a( URL_HTTP_DL. "/other/$fn.gz", $fn ) ,
			'full'	=> $annot[ 'full' ] ,
			'dir'	=> "$dn_other/$fn.d"
		];
	}
	foreach ( (array)$o_map as $a ) {
		extract( $a ); //$title, $file, $full, $dir
		$o_data->lev2( 'File', $file );
		$o_data->lev2( 'Annotation', $full );
		_prjslc( $dir );
		$o_data->end2( $title );
	}
*/
	//- info
	if ( file_exists( "$dn_other/info.txt" ) ) {
		$o_data->lev2( 'Details',
			preg_replace( '/[\n\r]+/', BR, file_get_contents( "$dn_other/info.txt" ) ) 
		);
	}

	//- img
	foreach ( $scandir as $fn ) {
		if ( ! _instr( 'thumb.jpg', $fn ) ) continue;
		//- tif画像か、jpg画像か
		$n = strtr( $fn, [ '.thumb.jpg' => '' ] );
		$l = ( substr( $n, -3 ) == 'tif' )
			? "$dn_other/$n.jpg" : URL_HTTP_DL. "/other/$n" ;
		$o_data->lev2( 'Image', _icap([
			'img' => "$dn_other/$fn" ,
			'url' => $l ,
			'cap' => "File: $n"
		]));
	}

	//- その他の型式
	if ( file_exists( "$dn_other/other.json" ) ) {
		foreach( _json_load( "$dn_other/other.json" ) as $fn => $sz ) {
			$sz = _format_bytes( $sz );
			$o_data->lev2( 'File', _a( URL_HTTP_DL. "/other/$fn" , "$fn ($sz)" ) );
		}
	}
	$o_data->end2( 'Others' );
}

//.. _prjslc(): プロジェクションと断面とヒストグラムを表示（サプリマップ用）
function _prjslc( $dn ) {
	global $o_data;
	$o_data->lev2( 'Projections & Slices',
		_t( 'table|#pstable', ''
			.TR
				.TH. _l( 'Axes' )
				.TH. _img( 'img/ori-z.gif' ). 'Z' 
				.TH. _img( 'img/ori-y.gif' ). 'Y' 
				.TH. _img( 'img/ori-x.gif' ). 'X'
			. _pstable_row( 'ori-pj', 'Projections' , 'proj0' , 'proj2' , 'proj3' , $dn )
			. _pstable_row( 'slc-2' , 'Slices (1/2)', 'slc_zb', 'slc_yb', 'slc_xb', $dn )
		)
	)->lev2( 'Density Histograms', ''
		. _icap([
			'url' => "$dn/hist.png" ,
			'img' => "$dn/hists.png" ,
			'cap' => 'Histogram' 
		])
		. _icap([
			'url' => "$dn/histlog.png",
			'img' => "$dn/histlogs.png",
			'cap' => 'Histogram (log scale)'
		])
	);
}
_simple()->time( 'suppli' );

//. Sample
$o_data->lev1title( 'Sample components', true );

//.. sample全体
$o_data
->lev3( 'name', SAMPLE_NAME )
->end3( 'Entire' )
->lev2( 'components', $sup_mol_list )
->end2( 'Entire|: ' . _span( '.h_addstr', _short( $main_json->sample->name ) ) )
;

$ids_all_macmol = array_values( _uniqfilt( _branch(
	$main_json ,
	'sample->macromolecule[*]->macromolecule_id'
)));

//.. sample 各要素
foreach ( [ 'supramolecule', 'macromolecule' ] as $mol_class ) {
	foreach ( (array)$main_json->sample->$mol_class as $num => $compo ) {
		$c_obj = [];
		$o_data->lev3order([ 'name', 'macmol_type', 'supmol_type' ]);

		//... valが単純
		foreach ( $compo as $key1 => $val1 ) {
			if ( $key1 == 'macromolecule_list' ) {
				$ids = array_values( _uniqfilt( _branch(
					$val1,
					'macromolecule->macromolecule_id'
				)));
				$val1 = $ids_all_macmol == $ids
					? _l( 'all' )
					: _conv_num( $ids )
				;
			}
			if ( is_object( $val1 ) || is_array( $val1 ) ) {
				$c_obj[ $key1 ] = true;
				continue;
			}
			//- ec
			if ( $key1 == 'ec_number' ) {
				$val1 = _obj('dbid')->pop( 'ec', $val1 );
			}

			$o_data->lev3( $key1, $val1 );
		}
		$o_data->end3( $mol_class );

		//... valが配列かオブジェクト
		foreach ( array_keys( $c_obj ) as $key1 ) {
			foreach ( is_array( $compo->$key1 ) ? $compo->$key1 : [ $compo->$key1 ]
				as $num2 => $val2 
			) {
				$o_data->lev3ign([
					'database', 'ncbi', 'organism.ncbi', 'recombinant_organism.ncbi'
				]);
				$o_data->lev3order([
					'organism', 'recombinant_organism'
				]);
				_prep_unit( $val2 );
				foreach ( (array)$val2 as $key3 => $val3 ) {
					//- 生物種
					if ( in_array( $key3, [ 'organism', 'recombinant_organism' ] ) )
						$val3 = _quick_taxo( $val3 );
						
					//- 配列
					if ( $key3 == 'string') {
						$val3 = _seqstr( $val3 );
					}
					//- ref
					if ( substr( $key3, 0, 4 ) == 'ref_' ) {
						$type = explode( '_', $key3, 2 )[1];
						$items = [];
						foreach ( ( is_array( $val3 ) ? $val3 : [ $val3 ] ) as $i ) {
							if ( $type == 'GO' )
								$i = _numonly( $i );
							$items[] = _obj('dbid')->pop( $type, $i );
						}
						$key3 = $type;
						$val3 = _imp( $items );
					}
					
					$o_data->lev3( $key3, _to_str( $val3 ) );
				}
				$o_data->end3( $key1 );
			}
		}
		//... 化合物？
		if ( $compo->macmol_type == 'ligand' ) {
			$chem_id = _ezsqlite([
				'dbname' => 'chem' ,
				'select' => 'id' ,
				'where' => [ 'name', $compo->name ] ,
			]);
			if ( $chem_id ) {
				$o_data->lev2(
					'Chemical component information' ,
					_ent_catalog( 'chem-'. $chem_id, [ 'mode' => 'list' ])
				);
			}
		}
		//... まとめ
		$o_data->end2( _trep( $mol_class )
			. '|'
			. ' '. _sharp( $compo->macromolecule_id ?: $compo->supramolecule_id ?: $num )
			. ': '. _span( '.h_addstr', _short( $compo->name ) )
		);
	}
}

_simple()->time( 'sample' );
//. Experiment
$o_data->lev1title( 'Experimental details', true, false );
//.. structure_determination (概要)

$o_data->lev2( 'method', _imp( TERM_STAIN, TERM_CRYOEM ) );
$o_data->lev2( 'Processing', TERM_REC_MET );
$o_data->lev2ign([ 'structure_determination_id', 'method' ]);
foreach ( $main_json->structure_determination[0] as $key => $val ) {
	if ( ! is_string( $val ) ) continue;
	if ( $key == 'aggregation_state' ) {
		$val = strtr( $val,[
			'twoD'   => '2D' ,
			'threeD' => '3D' ,
			'Array'  => ' array'
		]);
	}
	
	$o_data->lev2( $key, $val );
}
$o_data->end2( 'structure_determination' );

//.. 残り全部 pre
//... 配置換え
define( 'TAG_RELOC', [
	'microscopy' => [
		'electron beam' => [
			'acceleration_voltage' ,
			'electron_source' ,
		],
		'electron optics'  => [
			'c2_aperture_diameter', 
			'calibrated_defocus_max' ,
			'calibrated_defocus_min' ,
			'calibrated_magnification' ,
			'illumination_mode' ,
			'imaging_mode' ,
			'nominal_cs' ,
			'nominal_defocus_max' ,
			'nominal_defocus_min' ,
			'nominal_magnification'  ,
			'camera_length' ,
		] ,
		'sample stage' => [
			'specimen_holder' ,
			'specimen_holder_model'  ,
			'cooling_holder_cryogen' ,
			'tilt_angle_min' ,
			'tilt_angle_max' ,
			'tilt_angle' ,
			'tilt_series' ,
		]
	],
	'modelling' => [
		'refinement' => [
			'refinement_space' ,
			'refinement_protocol' ,
			'overall_bvalue' ,
			'target_criteria' ,
		]
	]
]);

//... 順番
define( 'MET_TAG_ORDER', [
	'microscopy' => [
		'microscope' ,
		'electron beam' ,
		'electron optics' ,
		'specialist_optics' ,
		'sample stage' ,
		'temperature' ,
	] ,
	'processing' => [
		'crystal_parameters' ,
		'crystallography_statistics' ,
		'molecular_replacement' ,
		'particle_selection' ,
		'segment_selection' ,
		'extraction' ,
		'ctf_correction' ,
		'startup_model' ,
		'symmetry_determination_software_list' ,
		'final_two_d_classification' ,
		'initial_angle_assignment' ,
		'final_three_d_classification' ,
		'final_angle_assignment' ,
		'final_reconstruction' ,
		'merging_software_list' ,
		'details' ,
	] ,
]);

//... タグの種類
define( 'TAG_TYPE', [
	'met' => [
		'energy_filter.name' => 'e' ,
		'electron_source'=> 'e', 
		'film_or_detector_model' => 'e' ,
		'microscope' => 'e' ,
		'instrument' => 'e' ,
		'phase_plate' => 'e' ,
		'grid.model' => 'e' ,
		'specimen_holder' => 'e' ,
		'specimen_holder_model' => 'e' ,
		'sph_aberration_corrector' => 'e' ,
		'detector_mode' => 'm' ,
		'software.name' => 's' ,
	],
	'_' => [
		'initial_model.access_code' => 'pdb' ,
		'pdb_id' 			=> 'pdb' ,
		'emdb_id'			=> 'emdb' ,
		'point_group'		=> 'symmetry' ,
		'axial_symmetry'	=> 'symmetry' ,
		'imaging_mode'		=> 'wikipe' ,
		'formula'	=> 'formula' ,
		'name'	=> 'wikipe' ,
	] ,
	'table' => [
		'component' => true ,
		'software' => true ,
		'initial_model' => true ,
//		'image_recording' => true , //- 子要素に枝があるのでうまくテーブル化できない
		'fiducial_marker' => true,
		'shell' => true
	]
]);

//... 一個しかない手法タイプはIDを消す
$type2name = [
	'preparation'	=> 'Sample preparation' ,
	'microscopy'	=> 'Electron microscopy' ,
	'processing'	=> 'Image processing' ,
	'modelling'		=> 'Atomic model buiding' ,
];
$type2idname = [
	'preparation'	=> 'preparation_id' ,
	'microscopy'	=> 'microscopy_id' ,
	'processing'	=> 'image_processing_id' ,
	'image_recording' => 'image_recording_id' ,
	'support_film'	=> 'film_type_id' ,
];

//- processing中にimage_recording_idがある
$flg_single_id = [];
$flg_single_tag = [];
foreach ([
	'preparation'	=> 'preparation' , 
	'microscopy'	=> 'microscopy' , 
	'processing'	=> 'processing' ,
	'image_recording' => 'microscopy->image_recording' ,
	'support_film'	=> 'preparation[*]->grid->support_film'
] as $type => $branch ) {
	if ( count(
		_branch( $main_json->structure_determination[0], $branch )
	) == 1 ) {
		$flg_single_tag[ $type ] = true;
		$flg_single_id[ $type2idname[ $type ] ]=  true;
	}
}
//_testinfo( $flg_single_id, 'flg_single_id' );
//_testinfo( $flg_single_tag, 'flg_single_tag' );

//.. 残り全部 メイン info
foreach ([
	'preparation'	=> $main_json->structure_determination[0]->preparation, 
	'microscopy'	=> $main_json->structure_determination[0]->microscopy, 
	'processing'	=> $main_json->structure_determination[0]->processing,
	'modelling'		=> $main_json->interpretation->modelling,
] as $type => $c0 ) foreach ( (array)$c0 as $type_num => $c ) {

	//... 前処理 タグ再配置
	foreach ( (array)TAG_RELOC[ $type ] as $to => $from_list ) {
		$c->$to = new stdClass;
		foreach ( $from_list as $from ) {
			if ( $c->$from ) {
				$c->$to->$from = $c->$from;
				unset( $c->$from );
			}
			if ( $c->{"$from.units"} ) {
				$c->$to->{"$from.units"} = $c->{"$from.units"};
				unset( $c->{"$from.units"} );
			}
		}
	}
	$o_data->lev2order( (array)MET_TAG_ORDER[ $type ] );

	//... 本処理
	_expmet_lev( $c );

	//... emn 追加情報
	if ( $type == 'processing' ) {
		if ( file_exists( _fn( 'fsc_img_s', ID ) ) ) {
			$o_data->lev2(
				TERM_FSC_DESC. _obj('wikipe')->get('Fourier shell correlation')->pop(),
				_img_sl( 'fsc_img_s', 'fsc_img_l' )
			);
		}
	} else if ( $type == 'modelling' ) {
		$o_data->lev2(
			'Output model',
			_ent_catalog( _emn_json( 'fit', DID ), [ 'mode'=>'list' ] )
		);
	} else if ( $type == 'microscopy' ) {
		$o_data->lev2( 'Experimental equipment', _eqimg( $c->microscope ) );
	}
	
	//... 見出し
	$o_data->end2( $type2name[ $type ]
		. ( $flg_single_tag[ $type ]
			? ''
			: '| '. _sharp( $c->{ $type2idname[ $type ] } ?: $type_num + 1 )
		)
	);
}

//.. func _expmet_lev (多重処理)
function _expmet_lev( $obj, $parents = [] ) {
	global $flg_single_id;
	$parents_rep = [];
	foreach ( array_slice( $parents, 1 ) as $p ) {
		$parents_rep[] = is_numeric( $p ) ? "#$p" :  _trep( $p );
	}
	$parents_rep = array_filter( $parents_rep );
	$parents_rep = $parents_rep
		? implode( ' - ', $parents_rep ). ' - '
		: ''
	;
	_prep_unit( $obj );
	foreach ( (array)$obj as $key => $val ) {
		if ( $flg_single_id[ $key ] ) continue;
		if ( is_array( $val ) && count( $val ) == 1 ) $val = $val[0];
		if ( TAG_TYPE['table'][ $key ] )
			$val = _to_table( $val, $key, $parents );
		if ( is_string( $val ) ) { 
			//- val
			$val = _val_prep( $val, $key, $parents );
			//- 出力
			if ( ! $parents ) {
				_set_data()->lev2( $key, $val );
			} else {
				_set_data()->lev3(
					$parents_rep. _trep( $key ),
					$val
				);
			}
		} else {
			//- 再帰呼び出し
			_expmet_lev( $val, array_merge( $parents, [ $key ] ) );
		}
		if ( ! $parents )
			_set_data()->end3( $key );
	}
}

_simple()->time( 'exp.' );

//.. func: _valrep
function _val_prep( $val, $key, $parents = [] ) {
	//- 既にhtmlタグが付いている？
	if ( _instr( '<', $val ) ) return $val;

	$info = null;
	//... タグ種類判別
	foreach ( TAG_TYPE as $type => $key_match ) {
		if ( $key_match[ $key ] ) {
			$info = $key_match[ $key ];
			break;
		}
		foreach ( $key_match as $keym_key => $keym_val ) {
			if ( ! _instr( '.', $keym_key ) ) continue;
			list( $keym0, $keym1 ) = explode( '.', $keym_key );
			if ( $keym1 == $key && in_array( $keym0, $parents ) ) {
				$info = $keym_val;
				break 2;
			}
		}
	}
	//... 変換
	if ( $info ) {
		if ( $type == 'met' )
			return _met_pop( $val, $info );
		if ( $info == 'symmetry' )
			return _symmetry_text( $val );
		if ( $info == 'wikipe')
			return $val . _obj('wikipe')->pop_xx( $val );
		if ( $info == 'formula')
			return _reg_rep( $val, [ '/[0-9]+/' => '<sub>$0</sub>' ] )
				. _obj('wikipe')->pop_xx( $val )
			;
		if ( $info == 'pdb' )
			return BR. _ent_catalog( 'pdb-'. $val, [ 'mode'=>'icon' ] );
		if ( $info == 'emdb' )
			return BR. _ent_catalog( $val, [ 'mode'=>'icon' ] );
	}
	return $val;
}

//.. _to_table
function _to_table( $val, $key, $parents = [] ) {
	if ( ! is_array( $val ) || count( $val ) < 2 ) return $val;
	foreach ( $val as &$obj ) {//- unitを処理しておく
		_prep_unit( $obj );
	}
	unset( $obj );
	$parents = array_merge( [ $key ], $parents );
	//- 行ヘッダ
	$heads = [];
	foreach ( $val as $c ) foreach ( $c as $k => $v ) {
		$heads[ $k ] = true;
		$heads_rep[ _trep( $k ) ] = true;
	}

	//- 一行のみなら、コンマ区切り	
	if ( count( $heads ) == 1 ) {
		$out = [];
		foreach ( $val as $c ) {
			$out[] = _val_prep( $c->$k, $k, $parents );
		}
		return '('. _trep( $k ). ': '. _imp( $out ). ')';
	}

	//- テーブル作成
	$rows = [];
	foreach ( $val as $c ) {
		$r = [];
		foreach ( array_keys( $heads ) as $k ) {
			$r[] = is_string( $c->$k )
				? _val_prep( $c->$k, $k, $parents )
				: _to_str( $c->$k )
			;
		}
		$rows[]= TD. implode( TD, $r );
	}
	return _t( 'table', ''
		. TR_TOP. TH. implode( TH, array_keys( $heads_rep ) ) 
		. TR. implode( TR, $rows )
	);
}

//. function
//.. _pstable_top: 断面図テーブルのヘッダ
function _pstable_top( &$map_info, $src, $xyz ) {
	global $map_info;
	return 	TD
		. round( $map_info->{"APIX $xyz"}, 2 ). ' &Aring;/pix.' .BR
		. 'x '. $map_info->$src. ' pix.' . BR
		. '= '. rtrim( $map_info->{"$xyz length"}, '0' ) . ' &Aring;'
	;
}

//.. _pstable_row: pngへのアンカー: jpgイメージ td (プロジェクションなど用)
function _pstable_row( $img, $name, $in1, $in2, $in3, $dn = '' ) {
	global $dn_media;
	$flg_main = ! $dn;
	$ret = TR.TH. _img( "img/$img.gif" )
		. _xbtn( '_slcimg.hide(this)', 'style: display:none' )
		.BR. _l( $name )
	;
	foreach ( [ $in1, $in2, $in3 ] as $s ) {
		$o = '';
		if ( $flg_main ) {//- メインマップ以外？
			$dn = "$dn_media/mapi";

			//- スライスのホバーで線を出す用のIDとclass
			$i = [
				'proj0'  => 'slc_z_',
				'proj2'  => 'slc_y_',
				'proj3'  => 'slc_x_',
				'surf_x' => 'slc_xs',
				'surf_y' => 'slc_ys',
				'surf_z' => 'slc_zs'
			][ $s ] ?: $s;
			$o = "#$i | .slc";
		}
		$ret .= TD . _ab( "$dn/$s.png", _img( $o, "$dn/$s.jpg" ) );
	}
	return $ret;
}

//.. _prep_unit 単位と、ソフトウェアバージョン
function _prep_unit( &$obj ) {
	foreach ( (array)$obj as $key => $val ) {
		if ( ! _instr( '.units', $key ) ) continue;
		$p = explode( '.', $key, 2 )[0];
		if ( $val == 'MDa' ) {
			if ( $obj->$p < 0.001 ) {
				$obj->$p = ( $obj->$p * 1000000 ). ' Da';
			} else if ( $obj->$p < 1 ) {
				$obj->$p = ( $obj->$p * 1000 ). ' KDa';
			} else {
				$obj->$p = $obj->$p. ' MDa';
			}
		} else {
			$obj->$p .= ' '. ( UNIT_REP['full'][ $val ] ?: strtr( $val, UNIT_REP['rep'] ) );
		}
		unset( $obj->$key );
	}
	if ( $obj->name && $obj->version ) {
		$obj->name = _met_pop( $obj->name, 's' ). ' (ver. '. $obj->version. ')';
		unset( $obj->version );
	}
}

//.. _to_str: 配列やオブジェクトを無理やり文字列化
function _to_str( $in ) {
	return is_string( $in ) ? $in
		: _reg_rep( json_encode( $in ), [
			'/[\[\]{}"]/' => '',
			'/(:|,)/' => '$1 ' ,
			'/^null$/' => '' ,
		])
	;
}
