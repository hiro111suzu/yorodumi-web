<?php
//. init
$json1 = $json;
$json3 = _emdb_json3_rep( _json_load2( _fn( 'emdb_json3', ID ) ) );

_add_lang( 'quick-emdb' );
_add_trep( 'quick-emdb' );

_add_fn(   'quick-emdb' );
_add_url(  'quick-emdb' );
_add_unit( 'quick-emdb' );

//$ftpdir = _url( 'ftpdir' );

define( 'URL_HTTP_DL', _url( 'url_http_dl', ID ) );

define( 'MAP_EX'	 , $main_id->ex_map() );
define( 'MOV_EX'	 , $main_id->ex_mov() );
define( 'MOLDATA_EX' , $main_id->ex_polygon() );

define( 'TERM_REC_MET', _met_pop([
	'e' => 'electron microscopy' ,
	't' => 'electron tomography' ,
	'a' => 'subtomogram averaging' ,
	's' => 'single particle reconstruction' ,
	'i' => 'single particle reconstruction' ,
	'h' => 'helical reconstruction' ,
	'2' => 'electron crystallography' 
][ $main_id->add()->met ], 'm' ) ); //- metではicosがない、英語で返す必要がある

define( 'TERM_CRYOEM', $main_id->add()->cryo ?
	_met_pop( 'cryo EM', 'm' )
	: ''
);

define( 'TERM_STAIN', $main_id->add()->stained
	? _met_pop( 'negative staining', 'm' )
	: ''
);

$dn_media = DN_EMDB_MED . "/$id";

_define_term( <<<EOD
TERM_IMG_UNDER_PREP
	Images and movies for this entry are currently under preparation
	このエントリの画像及び動画は現在準備中です
TERM_CUBIC_LATTICE
	generated in cubic-lattice coordinate
	これらの図は立方格子座標系で作成されたものです
TERM_SPIDER_IMG
	Images are generated by _1_.
	画像は _1_ により作成
TERM_FSC_DESC
	FSC plot (resolution estimation)
	FSC曲線 (解像度の算出)
TERM_SEGMENTATION
	Segmentation
	セグメンテーションマップ
TERM_ADDITIONAL_MAP
	Additional map
	追加マップ
TERM_HALFMAP
	Half map
	ハーフマップ
EOD
);
//. 追加データ
$mov_info = $main_id->movjson(); //- ムービー情報
$map_info = $main_id->mapjson(); //- マップ情報


$_simple->time( 'emdb init' );

//. basic
//.. sample compo scan
/*
タンパク質名リスト
概要名称リスト
UniProt検索リンク 管理用
由来情報
*/
$flg_unp_links = ( TEST && 
	_tsv_load( DN_PREP. '/unp/emdb_unpids_annot.tsv')[ ID ] == '_' )
;
$abst_names = [];
$unp_link_test = [];
$src = [];
$syn = [];
foreach ( (array)$json1->sample->sampleComponent as $c ) {

	$name = (string)$c->sciName ?: (string)$c->synName ?: '?' ;

	//- src
	foreach ( (object)$c as $k => $v ) {
		if ( ! $k ) continue;
		$n = $v->natSpeciesName ?: $v->sciSpeciesName ;
		if ( $n ) {
			$nl = strtolower( $n );
			$src[ $nl ] = $n;
			$syn[ $nl ][] = $v->synSpeciesName;
		}
	}
	//- abst name
	$n = in_array( $c->entry, [ 'protein', 'cellular-component' ] )
		? $name : $c->entry;
	if ( $n != $json1->sample->name )
		$abst_names[] = $n;

	//- その他 (test)
	if ( $c->entry == 'protein' ) {
		if ( $flg_unp_links ) {
			$t = "$name ". (string)$c->protein->sciSpeciesName;
			$unp_link_test[] = _ab([ 'unp_search', $t ], $t );
		}
	}
}

define( 'FLG_MANY_ENT', 5 < count( $json1->sample->sampleComponent ) );

//.. sample name
$s = _x( $json3->sample->name );
$sample_name = _ezsqlite([
	'dbname' => 'taxoid' ,
	'where'	 =>	[ 'name', $s ] ,
	'select' => 'id' ,
]) ? _quick_taxo( $s ) : _f( $s );

//.. sample-compo グループ化
$group_names = _group_name( $abst_names );
$out = [];
foreach ( $abst_names as $n ) {
	foreach( (array)$group_names as $g ) {
		if ( !_headmatch( $g, $n ) ) continue;
		$n = "$g ...";
		break;
	}
	++ $out[ $n ];
}

$compo = [];
foreach ( $out as $t => $cnt ) {
	$w = _obj('wikipe')->pop_xx( $t );
	$compo[] = $cnt == 1 ? $t.$w : "($t$w) x $cnt";
}

//- 長い文字列のやつがあったら箇条書き
$flg = false;
foreach ( $compo as $s ) {
	if ( strlen( strip_tags( $s ) ) < 40 ) continue;
	$flg = true;
}
$compo = $compo
	? ( $flg ? _ul( $compo ) : ':' . BR . _long( $compo, 10 ) )
	: ''
;

//.. taxo
//$_simple->time( 'basic taxo前' );
$src_items = [];
foreach ( $src as $k => $v ) {
	$src_items[] = _quick_taxo( $v, array_filter( $syn[ $k ] )[0] );
}
//$_simple->time( 'basic taxoあと' );

//.. citation
$citation = new cls_citation();
//- primary
$journal     = $json1->deposition->primaryReference->journalArticle;
$non_journal = $json1->deposition->primaryReference->nonJournalArticle;
if ( ! $citation->pubmed_json( $main_id->add()->pmid ) ) {
	$non_journal
		? $citation->emdb_non_journal( $non_journal )
		: $citation->emdb_json( $journal )
	;
}
//- secondary
$cnt = 1;
foreach ( (array)$json1->deposition->secondaryReference as $x ) {
	$journal     = $x->journalArticle;
	$non_journal = $x->nonJournalArticle;
	if ( ! $citation->pubmed_json(
		$journal->ref_pubmed . $non_journal->ref_pubmed , $cnt
	) ) {
		$non_journal
			? $citation->emdb_non_journal( $non_journal, $cnt )
			: $citation->emdb_json( $journal, $cnt )
		;
	}
	++ $cnt;
}

//.. history
//... supersession
$date = [];
$history = [];
$c = $json3->admin->obsolete_list->entry;
if ( $c ) {
	$history[] = [
		'date'	=> $date[] = $c->date ,
		'event'	=> 'Supersession' ,
		'ID'	=> _ab( [ 'quick', $c->entry ],  $c->entry ) ,
		'show'	=> true
	];
}

//... date
foreach ( $json3->admin->key_dates as $k => $v ) {
	$history[] = [
		'date'	=> $date[] = $v ,
		'event'	=> $k ,
		'show'	=> in_array( $k, [ 'deposition', 'map_release' ] )
	];
}

//... current
$c = $json3->admin->current_status;
if ( $c ) {
	$history[] = [
		'date'		=> $c->date ?: max( $date ),
		'event'		=> 'current status' ,
		'processing site' => $c->processing_site  ,
		'Status'	=> _trep( $c->code ) ,
		'show'		=> true ,
	];
}

//.. funding
$funding = [];
$flags = [];
$num = 0;
$country_jname = _subdata( 'e2j', 'country' );
foreach ( (array)$json3->admin->grant_support->grant_reference as $c ) {
	$f = ''
		. _country_flag( $c->country )
		. _ej(
			$c->country ,
			$country_jname[ $c->country ] ?: $c->country
		)
	;
	$funding[] = [
		$c->funding_body ,
		$c->code ,
		$f
	];
	++ $num;
	$flags[] = $f;
}

if ( $funding ) {
	$flags[] = $num. _ej( ' items', '件' );
	$funding = _imp( _uniqfilt( $flags ) ) . ' '
		. _more( _table_toph(
			[ 'Organization', 'Grant number', 'Country' ],
			$funding,
			[ 'opt' => '.smaller' ] 
		))
	;
}
unset( $flags, $country_jname );

//.. f&h annotation mng用
$fh_annot = '';
if ( TEST ) {
	define( 'EMDB_UNP_TSV', _tsv_load( DN_EDIT. '/unpid_emdb_annot.tsv' ) );
	$pmid = $main_id->add()->pmid;
	if ( EMDB_UNP_TSV[ $pmid ] ) {
		$fh_annot = _span( '.red', ''
			. EMDB_UNP_TSV[ $pmid ]
			. ' <= '
			. _ab( 'pap.php?id='. $pmid, 'PMID:'. $pmid )
		);
	} else if ( _flg_emdb_unp( ID ) ) {
		$fh_annot = _input_emdb_unp( ID, $pmid );
	}
}

//.. validation report EMDB
$v = "validation_reports/EMD-$id";
$dn = TESTSV
	? DN_FDATA. "/emdb-mirror/$v"
	: "/home/archive/ftp/pdbj/pub/emdb/$v"
;
if ( is_dir( $dn ) ) {
//	$ftp = "http://ftp.pdbj.org/pub/emdb/$v";
	$l = 'validation_rep.php?id=e'. ID.'&type=';
	$valrep = _imp(
		_ab( $l. 'pdf'	, IC_DL . _ej( 'Summary', '簡易版' ) ) ,
		_ab( $l. 'full'	, IC_DL . _ej( 'Full report', '詳細版' ) ) ,
		_ab( $l. 'xml'	, IC_DL . 'XML'  ) ,
		_ab( 'https://www.wwpdb.org/validation/2017/EMMapValidationReportHelp',
		 IC_L. TERM_ABOUT_VALREP )
	);
}

//.. output
function _f( $s ){
	return _x( $s ) . _obj('wikipe')->pop_xx( $s );
}

$o_data->basicinfo([
	'flg_vis'        => MOV_EX ,
	'flg_link'       => true ,
	'js_open_viewer' => MOV_EX ? "_pmov.open('$did')" : '',
	'add_txt'		 =>
		! file_exists( _fn( 'emdb_snap', ID, 's1' ) ) &&
		! file_exists( _fn( 'emdb_snap', ID, 's2' ) )
			? _p( LABEL_YM_ANNOT. TERM_IMG_UNDER_PREP )
			: ''
	, 
])
->lev1ar([
	'Title'				=> _f( $json3->admin->title ) ,
	'Map data'			=> _f( $json3->map->annotationDetails ). _hdiv_focus( 'map' ),
	'Sample'			=> $sample_name. $compo. _hdiv_focus( 'sample' ),
	'Keywords'			=> _keywords( $json3->admin->keywords ) ,
	'func_homology'		=> _func_homology(),
	'F&H annot'			=> $fh_annot ,
	'EMN category'		=> _emn_categ() ,
	'Biological species' => _imp2( $src_items ) ,

	'Method'			=> _imp2([ TERM_REC_MET, TERM_CRYOEM, TERM_STAIN,
		_ifnn( $main_id->add()->reso, _quick_kv([ 'Resolution' => '\1 &Aring' ]) )
	]) . _hdiv_focus( 'experimental' )
	,
	'Authors'			=> _authlist( $main_id->add()->author ),
	'Funding support' 	=> $funding ,
	'Citation'			=> $citation->output() ,
//	'Validation Report' => _validation_rep( $fit_pdb ) ,
	'Validation Report' => $valrep ,
	'History'			=> _history_table( $history )
]);
$_simple->time( 'basic' );

unset( $citation, $history, $compo, $funding );

//. visualization
//.. ムービー、ビューア
_viewer();

//.. sup-fig
//$sup_images = '';
$out = '';
//- imagesディレクトリの中
foreach ( glob( "$dn_media/images/*.thumb.jpg" ) as $tfn ) {
	$ffn = strtr( $tfn, [ '.thumb.jpg' => '' ] ); //- フルサイズの画像
	$fn = basename( $ffn );
	$out .= _icap([
		'img' => $tfn ,  //- thumb
		'cap' => strlen( $fn ) < 15 ? $fn : substr( $fn, 0, 12 ) . '...'  ,
		'url' => _instr( '.tif', $fn ) ? "$ffn.jpg" : $ffn
	]); 
}

//- EMDBの画像
if ( ! $out && _url_file_ex( 'emdb_fig', ID ) )
	$out = _icap([
		'url' => _url( 'emdb_fig_gif', ID ) ,
		'img' => _url( 'emdb_fig', ID ),
		'cap' => 'EMDB figure' ,
	]);

//- 'other'の画像
foreach ( glob( "$dn_media/other/*.thumb.jpg" ) as $tfn ) {
	$ffn = strtr( $tfn, [ '.thumb.jpg' => '' ] ); //- 元画像フルパス
	$fn = basename( $ffn ); //- 元画像ファイル名
	//- tif画像か、jpg画像か
	$out .= _icap([
		'url' =>_instr( '.tif', $fn ) ? "$ffn.jpg" : $ffn ,
		'img' => $tfn ,  //- thumb
		'cap' => ( strlen( $fn ) < 15 ) ? $fn : substr( $fn, 0, 12 ) . '...'
	]); 
}
$o_data->lev1( 'Supplemental images', $out );

//. ダウンロードとリンク
$o_data->lev1title( 'downlink', true );

//.. ダウンロード
$files = [
	$caps[ 'map' ] => [] ,
	$caps[ 'header' ] => [] ,
];

foreach ( _emn_json( 'filelist', DID ) as $type => $c ) {
	 foreach ( $c as $a ) {
		extract( (array)$a ); //- $name , $size
		$files[ $type ][] = _a( URL_HTTP_DL. "/$type/$name", IC_DL. $name )
			. _kakko( _format_bytes( $size ) )
		;
	}
}
$f = _url( 'ftpdir', ID );
$files['Archive directory'] = [
	_ab( URL_HTTP_DL, IC_L. URL_HTTP_DL ). ' (HTTP)',
	_ab( $f, IC_L. $f ). " (FTP)"
];

$caps = _ej([
	'map'		=> 'Map data',
	'header'	=> 'Header (meta data in XML format)',
	'fsc'		=> 'FSC (resolution estimation)',
	'images'	=> 'Images',
	'masks'		=> 'Masks (Map data of sub-region, etc)',
	'other'		=> 'Others',
	'slices'	=> 'Slices',
], [
	'map'		=> 'マップデータ',
	'header'	=> 'ヘッダ（付随情報, XML型式）',
	'fsc'		=> 'FSC (解像度算出)',
	'images'	=> '画像',
	'masks'		=> 'マスクデータ（部分マップなど）',
	'other'		=> 'その他',
	'slices'	=> '断面図',
]);

$add = [
	'map'		=> _hdiv_focus('map') ,
//	'header'	=> _ab( hdiv_focus('map') ,
	'masks'		=> _hdiv_focus('supplemental') ,
	'other'		=> _hdiv_focus('supplemental') ,
];

foreach ( $files as $type => $lnk ) {
	if ( $lnk )
		$lnk[] = $add[ $type ];
	$o_data->lev2( $caps[ $type ] ?: $type, _ul( (array)$lnk ) );
}

if ( TEST ) {
	$o_data->lev2(
		'FTP dir local' ,
		_ab([ '_mng-dir', 'fn' => 'emdb_ftp|'. ID ], 'FTP dir local' )
	);
}
$o_data->end2( 'Download' );

//.. 関連構造データ
( new cls_related([ 'is_em' => true ]) )
->set_omokage( 'e'. ID )
->set_similar([[ 'ida' => 'e'. ID ]])
->set_others()
->end();

//.. リンク
//	->lev3( '#notag',  )
//	->lev3( '#notag',  )
//... keyword for mom
$kw = [];
foreach ( (array)_json_load2([ 'pubmed', $main_id->add()->pmid ])->kw as $c ) {
	$kw[] = $c->name;
}
$kw[] = [ 
	'ribosome-c'	=> 'ribosome' ,
	'70s'			=> '70S Ribosomes' ,
	'80s'			=> 'ribosome' ,
	'amyloid' 		=> 'amyloid' ,
][ _ezsqlite([
	'dbname' => 'main' ,
	'select' => 'categ' ,
	'where'  => [ 'db_id', DID ]
])];

$kw[] = $json3->sample->name;
foreach ( (array)$json3->sample->supramolecule as $c ) {
	$kw[] = $c->name;
	$kw[] = $c->sci_species_name;
//	_testinfo( $c, 'supra' );
}
//_testinfo( $kw, 'kw' );
//_testinfo( $json3->sample );

//... output
$o_data
	->lev2( 'test', _test( _imp2([
		_ab([ 'json', DID ], 'jsonview' ) ,
		_ab([ 'json3', ID ], 'json3' ) ,
		( file_exists( _fn( 'emdb_json20', ID ) )
			? _ab([ 'jsonview', 'emdb_json20.'. ID ], 'JSON-v20' ) : ''
		),
		_ab([ 'txtdisp', 'a' => 'emdb_kw.'. ID ], 'search terms' ) ,
		_ab([ 'dir_emdb_med', ID ], _fa( 'folder' ) . 'media dir' )
		
	])))
	->lev2( 'EMDB pages', _imp2([
		_ab([ 'emdb_ent_ebi' , $id ], IC_L. 'EMDB (EBI/PDBe)' ) ,
		_ab([ 'emdb_ent_emdr', $id ], IC_L. 'EMDataResource' ),
	]))
//	->lev2( 'EM raw data', implode( BR, $emp_link ) )
	->lev2( TERM_REL_MOM, _mom_items( $kw ) )

	->end2( 'Links' )
;
//unset( $emp_json, $emp_link );
//_similar();
$_simple->time( 'dl&link' );

//. map data
$o_data->lev1title( 'Map' );
$map = $json3->map;

//.. file
$file = $map->file;
$o_data->lev1( 'File', MAP_EX
	? [
		'#notag' => _ab( _url( 'dl-map', ID ), IC_DL. _l( 'Download' ) ) ,
		'File'		=> $map->file ,
		'format'	=> $map->format ,
		'size' 		=> _format_bytes( $map->size_kbytes * 1000 ) ,
		'type'		=> $map->data_type ,
//		'label'		=> $map->label ,
	]
	: _trep( _x( $json1->deposition->status ) )
);

//.. projection / slices
if ( file_exists( "$dn_media/mapi/proj0.jpg" ) ) {

	//... スライスjs用パラメータ
	$slicejs = 1; //- javascript 実行する

	//- 「長い」と判断されたかどうか (「長い構造」のスライスは大きさが違う)
	$x = $map_info->NC;
	$y = $map_info->NR;
	$z = $map_info->NS;
	$a = [ $x, $y, $z ];
	rsort( $a );

	//- 長い構造？
	$long = $a[0] > $a[1] && $a[0] > $a[2];

	//- 薄い？
	if ( $a[2] * 10 < $a[0] && $a[1] * 10 < $a[0] ) $long = false;
	if ( $a[0] > 1000 ) $long = 0;

	if ( $long ) {
		$xr = $x / $a[0] / 6;
		$yr = $y / $a[0] / 6;
		$zr = $z / $a[0] / 6;
		$xa = [ 's' => 0, '_' =>  0, 'a' => 0.5 - $xr, 'b' => 0.5, 'c' => 0.5 + $xr ];
		$ya = [ 's' => 1, '_' =>  1, 'a' => 0.5 - $yr, 'b' => 0.5, 'c' => 0.5 + $yr ];
		$za = [ 's' => 0, '_' =>  0, 'a' => 0.5 - $zr, 'b' => 0.5, 'c' => 0.5 + $zr ];
		
		//- 0:横線 , 1:縦線
		$lv2r[0][ 'x' ] = $za;
		$lv2r[1][ 'x' ] = $ya;

		$lv2r[0][ 'y' ] = $za;
		$lv2r[1][ 'y' ] = $xa;

		$lv2r[0][ 'z' ] = $ya;
		$lv2r[1][ 'z' ] = $xa;
	} else {
		$lv2r[0][ 'x' ] = $lv2r[0][ 'y' ] =
		$lv2r[1][ 'y' ] = $lv2r[1][ 'z' ] =
			[ 's' => 0, '_' =>  0, 'a' => 1/3, 'b'=> 0.5, 'c' => 2/3 ];
		$lv2r[1][ 'x' ] = $lv2r[0][ 'z' ] =
			[ 's' => 1, '_' =>  1, 'a' => 1/3, 'b'=> 0.5, 'c' => 2/3 ];
	}
	$_simple->jsvar([ 'lv2r' => $lv2r ]);

	//- スライスラインを出力
	foreach ( [ 
		'slc_za', 'slc_zb', 'slc_zc',
		'slc_ya', 'slc_yb', 'slc_yc',
		'slc_xa', 'slc_xb', 'slc_xc',
		'slc_z_', 'slc_y_', 'slc_x_',
		'slc_xs', 'slc_ys', 'slc_zs'
	] as $n ) {
		$_simple->hidden .= _div( "#l_$n | .l_slc" );
	}

	//... output
	$n2xyz = [ 1 => 'X', 2 => 'Y', 3 => 'Z' ];
	$xyz_s = $n2xyz[ $map_info->MAPS ];
	$xyz_r = $n2xyz[ $map_info->MAPR ];
	$xyz_c = $n2xyz[ $map_info->MAPC ];
	$s = "input| type:range| autocomplete:off";

	$o_data->lev1( 'Projections & slices', ''
		. _btn( "!$('#slcimg_ctrl').toggle('fast')" ,
			_fa( 'sliders blue' ). _l( 'Image control' )
		)
		. _div( '#slcimg_ctrl', ''
			. _t( 'h2', _l( 'Image control' )
				. _btn( ".closebtn| !$('#slcimg_ctrl').hide('fast')", 'X' )
			)
			. _table_2col([
				'Size' => _e(
					"$s| value:100| min:100| max:500| step:10|"
					. '#sld_size| oninput:_slcimg.sldsize(this)'
				) ,
				'Brightness' => _e( 
					"$s| value:100| min:0| max:400| step:5|"
					. '#sld_brgt| oninput:_slcimg.filter()'
				) ,
				'Contrast' => _e(
					"$s| value:100| min:0| max:800| step:5| #sld_cont|"
					. 'oninput:_slcimg.filter()'
				) ,
				'Others' => ''
					. _chkbox( _l( 'Invert' ) ,
						'#chkb_invt| onchange:_slcimg.filter()| autocomplete:off', false )
					. _chkbox( _l( 'Y flip' ) ,
						'#chkb_yflip| onchange:_slcimg.yflip()| autocomplete:off', false )
					. ' '
					. _btn( '!_slcimg.reset()', _l( 'Reset' ) )
			])
		)

		//- テーブル
		. _t( 'table|#pstable', ''
			. TR
			. TH . _l( 'Axes' )
			. TH . _img( 'img/ori-z.gif' ) . "$xyz_s (Sec.)"
			. TH . _img( 'img/ori-y.gif' ) . "$xyz_r (Row.)"
			. TH . _img( 'img/ori-x.gif' ) . "$xyz_c (Col.)"
			. _e( 'tr | .small' )
			. TD
			. _pstable_top( $map_info, 'NS', $xyz_s )
			. _pstable_top( $map_info, 'NR', $xyz_r )
			. _pstable_top( $map_info, 'NC', $xyz_c )
			. ( file_exists( "$dn_media/mapi/surf_x.jpg" )
				? _pstable_row( 'ori-sf', 'Surface', 'surf_z', 'surf_y', 'surf_x' )
				: ''  
			)
			. _pstable_row( 'ori-pj', 'Projections', 'proj0', 'proj2', 'proj3' )
			. _pstable_row( 'slc-1', 'Slices (1/3)', 'slc_za', 'slc_ya', 'slc_xa' )
			. _pstable_row( 'slc-2', 'Slices (1/2)', 'slc_zb', 'slc_yb', 'slc_xb' )
			. _pstable_row( 'slc-3', 'Slices (2/3)', 'slc_zc', 'slc_yc', 'slc_xc' )
		)
		. _p( _term_rep( TERM_SPIDER_IMG, _met_pop( 'Spider', 's' ) ) )
		. (
			//- 直行座標じゃないマップ
			$map->cell->alpha != 90 || $map->cell->beta != 90 ||
			$map->cell->gamma != 90 ||
			$map->spacing->x != $map->spacing->y || $map->spacing->x != $map->spacing->z 
			? _p( '.red', TERM_CUBIC_LATTICE )
			: ''
		)
	);
}
$_simple->css( <<<EOD
//- プロジェクションとかのテーブル
#pstable, #pstable td, #pstable th {
	border: none; margin: 0; padding: 0; background: white; }
#pstable td, #pstable th {
	width: auto; height: auto; vertical-align: middle; text-align: center; }

//- スライスホバー
.slc { border: 2px solid transparent; }
.slc:hover { border: 2px solid #a00; }
.l_slc { display: none; position: absolute; border: 1px solid #a00;
	box-shadow: 0 0 3px #ffffff; z-index: 300; background: rgba(255,255,255,0.2); }

#slcimg_ctrl {
	display: none;
	position:fixed; left:1em; top:1em;
	background: rgba(255,255,255,0.5); box-shadow: 1px 1px 10px #777;
	z-index: 200;
	padding: 0;
}
#slcimg_ctrl input[type=range] { width: 200px;
}
#slcimg_ctrl h2 {
	font-syze: medium;
	background: $col_dark; color: white;
	margin: 0; padding: 0.2em; 
}
EOD
);

//.. voxel size
//- xml info
$xx = round( $map->pixel_spacing->x , 5 );
$xy = round( $map->pixel_spacing->y , 5 );
$xz = round( $map->pixel_spacing->z , 5 );

//- ccp4 header info
if ( $map_info != '' ) {
	$hx =round( $map_info->{'APIX X'} , 5 );
	$hy =round( $map_info->{'APIX Y'} , 5 );
	$hz =round( $map_info->{'APIX Z'} , 5 );
}

//- Movie info
if ( $mov_info !='' ) {
	$mx = _ifnn( round( $mov_info->{1}->{'apix x'}, 5 ), '\1', $hx );
	$my = _ifnn( round( $mov_info->{1}->{'apix y'}, 5 ), '\1', $hy );
	$mz = _ifnn( round( $mov_info->{1}->{'apix z'}, 5 ), '\1', $hz );
}

function _near( $a, $b ) {
	if ( $a == '' || $b == '' ) return true;
	if ( max( [ $a/$b, $b/$a ] ) < 1.1 ) return true;
}

//- 一致？
$o_data->lev1( 'Voxel size',

	_near( $xx, $hx ) && _near( $xx, $mx ) &&
	_near( $xy, $hy ) && _near( $xy, $my ) &&
	_near( $xz, $hz ) && _near( $xz, $mz )

	//- だいたい同じ
	? ( $xx == $xy && $xx == $xz
		? [ 'X=Y=Z' => "$xx &Aring;" ]
		: [ 'X' => "$xx &Aring;", 'Y' => "$xy &Aring;", 'Z' => "$xz &Aring;" ]
	)

	//- 無視できない違い
	: _table_2col([
		''						=> [ 'X', 'Y', 'Z' ] ,
		'EMDB info.'			=> [ $xx, $xy, $xz ],
		'CCP4 map header'		=> [ $hx, $hy, $hz ],
		'EM Navigator Movie #1' => $mx ? [ $mx, $my, $mz ] : '' 
	], [
		'opt'		=> '.itable | st:color:red',
		'multi_col'	=> true,
		'topth'		=> true 
	])
);

//.. density
//- 表面
$surf = [];
$num = 1;
foreach ( (array)$map->contour as $c ) {
	$n = ( $c->primary ? 'primary' : '' ) ?: _sharp( $num );
	$k = $c->source ? "By ". $c->source : $n;
	if ( $surf[ $k ] )
		$k .= _kakko( $n );
	$surf[ $k ] = $c->level;
	++ $num;
}

if ( $mov_info && $mov_info->{1}->mode != 'solid' )
	$surf['Movie #1'] = round( $mov_info->{1}->threshold, 7 );

$d = "$dn_media/mapi";
$ms = $map->statistics;

$o_data->lev1( 'Density',

	//- ヒストグラム
	( file_exists( "$d/hists.png" ) ? ''
		. _icap([
			'url' => [ 'histogram_l', ID ],
			'img' => [ 'histogram_s', ID ],
			'cap' => 'Histogram' ,
		])
		. _icap([
			'url' => [ 'histogram_log_l', ID ],
			'img' => [ 'histogram_log_s', ID ],
			'cap' => 'Histogram (log scale)' ,
		])
	: '')

	//- 表面レベルの表
	. _table_2col([
		'Contour Level'	=> _quick_kv( $surf ) ,
		'Minimum - Maximum' => $ms->minimum .' - '. $ms->maximum ,
		'Average (Standard dev.)'
			=> $ms->average . _kakko( $ms->std == 0 ? '-' : '&plusmn;'. $ms->std )
		],
		[ 'opt' => '.clboth' ]
	) 
);

//.. symmetry
//... symmetry
$sym = [];
foreach ( $map->symmetry as $k => $v ) {
	if ( is_string( $v ) )
		$sym[ $k ] = $v;
	else foreach( $v as $k2 => $v2 ) {
		$sym[ $k2 ] = $v2;
	}
}
$o_data->lev1( 'Symmetry', $sym );

//.. details

/*
if ( $map->symmetry->space_group ) {
	$sym['Space Group Number'] = $map->symmetry->space_group;
} else if ( {
$out =  TR.TH. _ej( 'Space Group Number', '空間群番号' ) .TD. $map->symmetry->space_group;
*/

//... ジオメトリ
$geo = [ 'Axis order' => [
	$map->axis_order->fast ,
	$map->axis_order->medium ,
	$map->axis_order->slow ,
]];

foreach( [ 'origin', 'dimensions', 'limit' ] as $n ) {
	$r = $c = $s = '';
	foreach ( (array)$map->$n as $k => $v ) {
		if ( _instr( 'row', $k ) ) $r = $v;
		if ( _instr( 'col', $k ) ) $c = $v;
		if ( _instr( 'sec', $k ) ) $s = $v;
	}
	if ( $r.$c.$s )
		$geo[ $n ] = [ $r, $c,  $s ];
}
$geo[ 'spacing' ] = [
	$map->spacing->x ,
	$map->spacing->y ,
	$map->spacing->z ,
];

//... cell

$a = $map->cell->a;
$b = $map->cell->b;
$c = $map->cell->c;
$d = $map->cell->alpha;
$e = $map->cell->beta;
$f = $map->cell->gamma;

$out = _p( '.bld', 'EMDB XML:' ). _table_2col([
	'Map geometry' => _table_2col( $geo, [ 'multi_col'=> true] )
	,
	_ej( 'Cell', 'セル'  ) => ''
		. ( $a == $b && $b == $c
			? _kv([ 'A=B=C' => "$a &Aring;" ])
			: _kv([
				'A' => "$a &Aring;" ,
				'B' => "$b &Aring;" ,
				'C' => "$c &Aring;"
			])
		)
		. BR
		. ( $d == $e && $e == $f
			? _kv([ '&alpha;=&beta;=&gamma;' => "$f &deg;" ])
			: _kv([
				'&alpha;' => "$d &deg;" ,
				'&beta;'  => "$e &deg;" ,
				'&gamma;' => "$f &deg;"
			])
		)
	,
]);


//... ccp4 header info
if ( $mov_info != '' && $main_id->status()->mov1 ) {
	$s = TR.TH. 'mode<td colspan=3>'. [ 
		0 => 'envelope stored as signed bytes (from -128 lowest to 127 highest)' ,
		1 => 'Image stored as Integer*27' ,
		2 => 'Image stored as Reals' ,
		3 => 'Transform stored as Complex Integer*2' ,
		4 => 'Transform stored as Complex Reals'
	][ $map_info->MODE ];

	foreach ( [
		'&Aring;/pix. X/Y/Z' => 'APIX X/APIX Y/APIX Z',
		'M x/y/z'			=> 'MX/MY/MZ',
		'origin x/y/z'		=> 'XORIGIN/YORIGIN/ZORIGIN',
		'length x/y/z'		=> 'X length/Y length/Z length',
		'&alpha;/&beta;/&gamma;' => 'Alpha/Beta/Gamma',
		'start NX/NY/NZ'	=> 'NXSTART/NYSTART/NZSTART',
		'NX/NY/NZ'			=> 'NX/NY/NZ',
		'MAP C/R/S'			=> 'MAPC/MAPR/MAPS',
		'start NC/NR/NS'	=> 'NCSTART/NRSTART/NSSTART',
		'NC/NR/NS'			=> 'NC/NR/NS',
		'D min/max/mean'	=> 'DMIN/DMAX/DMEAN'
	] as $t => $n ) {
		$a = [];
		foreach ( explode( '/', $n ) as $n1 )
			$a[] = $map_info->$n1;
		if ( ! implode( '', $a ) ) continue;
		$s .= TR.TH. $t .TD. implode( TD, $a );
	}
	$out .= _p( '.bld', _l('CCP4 map header' ) . ': ' )
		. _t( 'table', $s )
	;
}
$o_data->lev1( 'Details', _more( $out ) );

//. Supplement
$o_data->lev1title( 'Supplemental data', true );
$_out = '';
$_simple->time( 'map' );

//.. filename => annotation
$map_annot = [];
foreach ( (array)$json3->interpretation->segmentation_list->segmentation as $j ) {
	$map_annot[ $j->file ] = [
		'full' => $j->annotation_details ,
		'type' => TERM_SEGMENTATION ,
	];
}
foreach ( (array)$json3->interpretation->additional_map_list->additional_map as $j ) {
	$map_annot[ $j->file ] = [
		'full' => $j->annotation_details ,
		'type' => TERM_ADDITIONAL_MAP ,
	];
}
foreach ( (array)$json3->interpretation->half_map_list->half_map as $j ) {
	$map_annot[ $j->file ] = [
		'full' => $j->annotation_details ,
		'type' => TERM_HALFMAP 
	];
}
$num = [];
foreach ( $map_annot as $k => $v ) {
	$t = $v['type'];
	$map_annot[ $k ]['short'] = strlen( $v['full'] ) < 70
		? "$t: ". ( $v['full'] ?: '#'. ( ++ $num[ $v['type'] ] ) )
		: "$t: ". implode( ' ', array_slice( explode( ' ', $v['full'] ), 0, 8 ) ). '...'
	;
	if ( _instr( 'additional_1.map', $k ) ) {
		$k1 = strtr( $k, [ 'additional_1.map' => 'additional.map' ] );
		if ( ! $map_annot[ $k1 ] )
			$map_annot[ $k1 ] = $map_annot[ $k ];
	}
}
//_testinfo( $map_annot );

//.. mask
//- ファイル
$mskjson = _json_load( "$dn_media/masks/list.json" );
$addnum = $mskjson[ 0 ]  || $mskjson[ 1 ] ? 0 : 1;

$done = [];
$i = 0;
foreach ( (array)$json1->supplement->mask as $c1 ) {
	$f = $c1->file;
	$annot = $map_annot[ $f->name ];
	$o_data->lev2( 'Annotation', $annot['full'] );
	$o_data->lev2( 'File' ,
		_a( URL_HTTP_DL. "/masks/{$f->name}",
			IC_DL. $f->name. _kakko( "{$f->type} file in {$f->format} format, {$f->sizeKb} KB" )
		)
	);

	//- 画像
	if ( $mskjson[ $i + $addnum ] != '' )
		_prjslc( "$dn_media/masks/" . ( $i + $addnum ) );

	//- 文字情報
	foreach( $c1 as $n2=>$c2 ) {
		if ( $n2 == 'file' ) continue;

		//- 文字列
		if ( ! is_object( $c2 ) ) {
			$o_data->lev2( $n2, $c2 );
			continue;
		}
	}

	$done[ $i ] = 1;
	$i ++;
	$o_data->end2( $annot['short'] ?: "Mask|#$i" );
}

//- 書いていないのがあれば追加
foreach ( (array)$mskjson as $i => $fn ) {
	if ( $done[ $i ] ) continue;
	$annot = $map_annot[ $fn ];
	$o_data->lev2( 'Annotation', $annot['full'] );
	$o_data->lev2( 'File', _a( URL_HTTP_DL. "/masks/$fn", IC_DL . $fn ) );
	_prjslc( "$dn_media/masks/$i" );
	$o_data->end2( $annot['short'] ?: "Mask|#$i" );
}

//.. figure
//- 今のところ、EMDB-XML情報には、ファイル名しか書いてない、間違っているのも多い
//- なので使わない、実際にファイルがあるモノのみ、そのファイルを表示

//.. images
//if ( $sup_images != '' )
//	$_out .= _index( 2, 'Images' ) . _tr( 'Images', $sup_images );

//.. fsc
//- EMDB-XMLのFSCタグに、ファイル名以外の情報を持つデータは、存在しないので
//if ( file_exists( "$dn_media/fsc/fscs.jpg" ) ) {
//	$_out .= _index( 2, 'FSC' )
//		. _tr( 'FSC', _ab( "$dn_media/fsc/fscl.png", _timg( "$dn_media/fsc/fscs.jpg" ) ) );
//}

//.. other
$dn_other = "$dn_media/other";
$out = '';

if ( is_dir( $dn_other ) ) {
	$scandir = scandir( $dn_other );

	//- map
//	$o_map = [];
	foreach ( $scandir as $dn ) {
		if ( ! is_dir( "$dn_other/$dn" ) ) continue;
		if ( ! _instr( '.map.d', $dn ) && ! _instr( '.mrc.d', $dn ) ) continue;
		$fn = strtr( $dn, [ '.map.d' => '.map', '.mrc.d' => '.mrc' ] );
		$annot = $map_annot[ $fn ] ?: $map_annot[ "$fn.gz" ];
		$o_data->lev2( 'File', _a( URL_HTTP_DL. "/other/$fn.gz", $fn ) );
		$o_data->lev2( 'Annotation', $annot['full'] );
		_prjslc( "$dn_other/$dn" );
		$o_data->end2( $annot 
			? $annot['short']
			: _l( 'Supplemental map' ) . ": $fn"
		);
	}
/*
		$o_map[] = [
			'title'	=> $annot 
				? $annot['short']
				: _l( 'Supplemental map' ) . ": $fn"
			,
			'file'	=> _a( URL_HTTP_DL. "/other/$fn.gz", $fn ) ,
			'full'	=> $annot[ 'full' ] ,
			'dir'	=> "$dn_other/$fn.d"
		];
	}
	foreach ( (array)$o_map as $a ) {
		extract( $a ); //$title, $file, $full, $dir
		$o_data->lev2( 'File', $file );
		$o_data->lev2( 'Annotation', $full );
		_prjslc( $dir );
		$o_data->end2( $title );
	}
*/
	//- info
	if ( file_exists( "$dn_other/info.txt" ) ) {
		$o_data->lev2( 'Details',
			preg_replace( '/[\n\r]+/', BR, file_get_contents( "$dn_other/info.txt" ) ) 
		);
	}

	//- img
	foreach ( $scandir as $fn ) {
		if ( ! _instr( 'thumb.jpg', $fn ) ) continue;
		//- tif画像か、jpg画像か
		$n = strtr( $fn, [ '.thumb.jpg' => '' ] );
		$l = ( substr( $n, -3 ) == 'tif' )
			? "$dn_other/$n.jpg" : URL_HTTP_DL. "/other/$n" ;
		$o_data->lev2( 'Image', _icap([
			'img' => "$dn_other/$fn" ,
			'url' => $l ,
			'cap' => "File: $n"
		]));
	}

	//- その他の型式
	if ( file_exists( "$dn_other/other.json" ) ) {
		foreach( _json_load( "$dn_other/other.json" ) as $fn => $sz ) {
			$sz = _format_bytes( $sz );
			$o_data->lev2( 'File', _a( URL_HTTP_DL. "/other/$fn" , "$fn ($sz)" ) );
		}
	}
	$o_data->end2( 'Others' );
}

//.. _prjslc(): プロジェクションと断面とヒストグラムを表示（サプリマップ用）
function _prjslc( $dn ) {
	global $o_data;
	$o_data->lev2( 'Projections & Slices',
		_t( 'table|#pstable', ''
			.TR
				.TH. _l( 'Axes' )
				.TH. _img( 'img/ori-z.gif' ). 'Z' 
				.TH. _img( 'img/ori-y.gif' ). 'Y' 
				.TH. _img( 'img/ori-x.gif' ). 'X'
			. _pstable_row( 'ori-pj', 'Projections' , 'proj0' , 'proj2' , 'proj3' , $dn )
			. _pstable_row( 'slc-2' , 'Slices (1/2)', 'slc_zb', 'slc_yb', 'slc_xb', $dn )
		)
	)->lev2( 'Density Histograms', ''
		. _icap([
			'url' => "$dn/hist.png" ,
			'img' => "$dn/hists.png" ,
			'cap' => 'Histogram' 
		])
		. _icap([
			'url' => "$dn/histlog.png",
			'img' => "$dn/histlogs.png",
			'cap' => 'Histogram (log scale)'
		])
	);
}
$_simple->time( 'suppli' );

//. Sample
$o_data->lev1title( 'Sample components', true );

$order = [
	'name' ,
	'Name' , //-?
	'sciName' ,
	'synName' ,
	'class' ,
	'mutantFlag' ,
	'oligomericDetails' ,
	'numberOfCopies' ,
	'protein' ,
	'details' ,
	'structure' ,
	
	'host' ,
	'hostSpecies',
	'hostCategory',
	'hostSpeciesStrain',

	'sciSpeciesName' ,
	'synSpeciesName' ,
	'expSystem'  ,
	'sciSpeciesStrain' ,
	'organelle' ,
	'Tissue' ,
	'cellLocation' ,
	'cell' ,
	'mutant' ,
	'vector' ,
];

//.. sample全体
$o_data->lev3order( $order )
	->lev3ign([ 'sampleComponent', 'molWtTheo', 'molWtExp', 'molWtMethod' ]);
foreach ( $json1->sample as $k => $v ) {
	if ( $k == 'name' )
		$v = $sample_name;
	$o_data->lev3( $k, $v );
}
$o_data->end3( 'Entire' )
->lev2( 'Mass', _mol_wt( $json1->sample ) )
->end2( 'Entire|' . _span( '.h_addstr', _short( $json1->sample->name ) ) );

//.. sample 要素 事前
/*
$prot_names = [];
foreach ( $json1->sample->sampleComponent as $c ) {
//	if ( ! is_object( $c->protein ) ) continue;
//	$prot_names[] = 
}
*/

//.. sample 各要素

//- 第3階層があるデータは以下のみ
$_keys_lev3 = [ 'engSource', 'natSource', 'shell', 'externalReferences' ];


foreach ( $json1->sample->sampleComponent as $c1 ) {
	$flg_virus = $c1->entry == 'virus';
	$src = '';

	$o_data->lev3order( $order )
		->lev3ign([ 'entry', 'componentID', 'ncbiTaxId', 'sciSpeciesName', 'synSpeciesName',
			'sciSpeciesSerotype', 'sciSpeciesStrain', 'molWtTheo', 'molWtExp', 'molWtMethod'
		])
	;
	$ent = $c1->{ $c1->entry };

	//... 一般
	foreach ( $c1 as $n2=>$c2 ) {
		//- 文字列ならそのまま入れる
		if ( ! is_object( $c2 ) ) {
			$o_data->lev3( $n2, $c2 . _obj('wikipe')->pop_xx( $c2 ) );

		//- オブジェクト (Protein とか ribosomeとかなので、そのままのレベルで処理)
		} else foreach ( $c2 as $n3=>$c3 ) {
			//- level3がないタグのみ
			if ( in_array( $n3, $_keys_lev3 ) ) continue;
			$o_data->lev3( $n3, $c3 );
		}
	}
	$o_data->end3( $c1->entry )
	->lev2( 'Mass', _mol_wt( $c1 ) )
	->lev3order( $order );
		
	//... 種名
	//- ウイルスなら、種名が名称
	if ( $flg_virus ) {
		$o_data->lev3( 'Species' ,
			_quick_taxo( $ent->sciSpeciesName ?: $ent->name, $ent->synSpeciesName )
		)
			->lev3( 'Strain', $ent->sciSpeciesStrain )
			->lev3( 'Serotype',  $ent->sciSpeciesSerotype )
			->end3( 'Species' )
		;
	} else {
		$o_data
			->lev3( 'Species', _quick_taxo( $ent->sciSpeciesName, $ent->synSpeciesName ) )
			->lev3( 'Strain', $ent->sciSpeciesStrain )
			->lev3( 'Serotype',  $ent->sciSpeciesSerotype )
			->end3( 'Source' )
		;
	}

	//... source 3種
	//- engSource
	$o_data->lev3ign([ 'ncbiTaxId' ])->lev3order( $order );
	foreach ( (array)$ent->engSource as $n4 => $c4 ) {
		if ( in_array( $n4, [ 'expSystem', 'hostSpecies' ] ) )
			$c4 = _quick_taxo( $c4 );
		$o_data->lev3( $n4, $c4 );
	}
	$o_data->end3( 'engSource' );

	//- natSource
	$o_data->lev3ign([ 'ncbiTaxId' ])->lev3order( $order );
	foreach ( (array)$ent->natSource as $n4 => $c4 ) {
		if ( in_array( $n4, [ 'expSystem', 'hostSpecies' ] ) )
			$c4 = _quick_taxo( $c4 );
		$o_data->lev3( $n4, $c4 );
	}
	$o_data->end3( 'natSource' );

	//- hostSpecies
	$o_data->lev3ign([ 'ncbiTaxId' ])->lev3order( $order );
	foreach ( (array)$ent->hostSpecies as $n4 => $c4 ) {
		if ( in_array( $n4, [ 'expSystem', 'hostSpecies' ] ) )
			$c4 = _quick_taxo( $c4 );
		$o_data->lev3( $n4, $c4 );
	}
	$o_data->end3( 'hostSpecies' );

	//... shell
	foreach ( (array)$ent->shell as $n4 => $c4 ) {
		if ( $c4->nameElement != '' )
		$o_data->lev2( 'Shell|#' . $c4->id, [
			'nameElement'	=> $c4->nameElement ,  
			'Diameter'		=> _ifnn( $c4->diameter, '\1 &Aring;' ) ,
			'tNumber'		=> $c4->tNumber ,
		]);
	}

	//... ext ref
	foreach ( (array)$ent->externalReferences as $n4 => $c4 )
		$o_data->lev3( $n4, _emdb_dbid_link( $n4, $c4 ) );
	$o_data->end3( 'External references' );

	$o_data->end2( 'component|' . '#' . $c1->componentID
		. ': ' . _span( '.h_addstr', _short( _imp(
			_l( $c1->entry ), _l( $c1->sciName )
		)))
	);
}
$_simple->time( 'sample' );

//. Experiment
$o_data->lev1title( 'Experimental details', true, false );

//.. sample preparation / Vitrification
$jprep = $json1->experiment->specimenPreparation;

//... 状態
$o_data->lev2( 'specimen', [
	'specimenState' => _trep( $jprep->specimenState ) ,
	'method' => _imp( TERM_STAIN, TERM_CRYOEM )
]);

//... らせんパラメータ
$o_data->lev3order([ 'axialSymmetry', 'hand', 'deltaZ', 'deltaPhi' ]);
foreach ( (array)$jprep->helicalParameters as $k => $v ) {
	if ( $k == 'axialSymmetry' )
		$v = _symmetry_text( $v );
	$o_data->lev3( $k, $v );
}
$o_data->end3( 'helicalParameters' );

//... 結晶パラメータ
$o_data->lev3order([
	'planeGroup', 'spaceGroup', 'aLength', 'bLength', 'cLength', 'alpha', 'beta', 'gamma' 
]);
foreach ( (array)$jprep->twoDCrystalParameters as $k => $v ) {
	$o_data->lev3( $k, $v );
}
foreach ( (array)$jprep->threeDCrystalParameters as $k => $v ) {
	$o_data->lev3( $k, $v );
}
$o_data->end3( 'Crystal parameters' );

//... 結晶化法
$o_data->lev2( 'crystalGrowDetails', $jprep->crystalGrowDetails );

//... sample solution
$o_data->lev2( 'Sample solution', [
	'specimenConc'		=> $jprep->specimenConc ,
	'Buffer solution'	=> $jprep->buffer->details ,
	'ph'				=> $jprep->buffer->ph ,
]);

//... その他exp:
foreach ( [ 'specimenSupportDetails', 'staining' ] as $k ) {
	$o_data->lev2( $k, $jprep->$k );
}

//... vitrification
$flg_multi = count( $vit = $json1->experiment->vitrification ) > 1;
$num = 1;
foreach ( (array)$json1->experiment->vitrification as $n1 => $c1 ) {

	$o_data->lev3order(
		[ 'instrument', 'cryogenName', 'temperature', 'humidity', 'method' ]
	);
	foreach ( $c1 as $k => $v ) {
		$o_data->lev3( $k, $k == 'instrument' ? _met_pop( $v, 'e' ) : $v );
	}
	$o_data->end3( 'Vitrification' . ( $flg_multi ? "|#$num" : '' ) );
	++ $num;
}
$o_data->end2( 'Sample preparation' );

//.. Imaging
$flg_multi = count( $json1->experiment->imaging ) > 1;
$num = 1;
foreach ( $json1->experiment->imaging as $n1 => $o_img ) {

	//... EM
	$o_data->lev2( 'Experimental equipment', _eqimg( $o_img->microscope ) );
	$o_data->lev2( 'Imaging', [
		'microscope'	=> _met_pop( $o_img->microscope, 'e' ) ,
		'Date'			=> $o_img->date ,
		'details'		=> $o_img->details ,
	]);

	//... gun
	foreach ( [ 'electronSource', 'acceleratingVoltage', 'electronDose',
				'electronBeamTiltParams', 'illuminationMode' ] as $n )
		$o_data->lev3( $n, _wikipe_em( $n, $o_img->$n ) );
	$o_data->end3( 'Electron gun' );
	
	//... lens
	$o_data->lev3( 'Magnification', _imp( 
		_ifnn( $o_img->nominalMagnification, '\1 X ('. _l( 'nominal' ) . ')' ),
		_ifnn( $o_img->calibratedMagnification, '\1 X ('. _l( 'calibrated' ) . ')' )
	));

	foreach( [ 'astigmatism', 'nominalCs', 'imagingMode' ] as $n )
		$o_data->lev3( $n, _wikipe_em( $n, $o_img->$n ) );

	$min = $o_img->nominalDefocusMin;
	$max =  $o_img->nominalDefocusMax;
	if ( $min . $max != '' ) {
		$o_data->lev3( 'Defocus', $min != $max ? "$min - $max nm" : "$max nm");
	}
//	foreach ( [ 'energyFilter', 'energyWindow' ] as $n )
	$o_data
		->lev3( 'energyFilter', _met_pop( $o_img->energyFilter, 'e' ) )
		->lev3( 'energyWindow', _ifnn( $o_img->energyWindow, '\1 eV' ) )
	;

	$o_data->end3( 'lens' );

	//... Sample Holder
	$o_data
		->lev3( 'Holder' , $o_img->specimenHolder )
		->lev3( 'Model'  , $o_img->specimenHolderModel )
	;

	$min = $o_img->tiltAngleMin;
	$max = $o_img->tiltAngleMax;
	if ( $min || $max )
		$o_data->lev3( 'Tilt Angle', "$min - $max &deg;" );

	$max = $o_img->temperatureMax;
	$min = $o_img->temperatureMin;
	$o_data->lev3( 'Temperature' ,
		$o_img->temperature
		. ( $min . $max ? _kakko( "$min - $max K" ) : '' )
	);
		
	$o_data->end3( 'Specimen Holder' );

	//... camera
	$o_data->lev3( 'Detector', _met_pop( $o_img->detector, 'e' ) );
	if ( $o_img->detectorDistance ) {
		$o_data->lev3( 'Distance', $o_img->detectorDistance );
	}
	$o_data->end3( 'Camera' );

	//... output
	$o_data->end2( 'Electron microscopy imaging' . ( $flg_multi ? "|#$num" : '' ) );
	++ $num;
}

//.. imageAcquisition
$flg_multi = count( (array)$json1->experiment->imageAcquisition ) > 1;
$o_data->lev3order([
	'numDigitalImages',
	'scanner',
	'samplingSize',
	'quantBitNumber',
	'odRange',
	'details',
	'URLRawData',
]);

foreach ( (array)$json1->experiment->imageAcquisition as $n1 => $c ) {
	foreach ( (array)$c as $k => $v ) {
		$o_data->lev3( $k, _instr( 'URL', $k ) && $v != '' ? _ab( $v, $v ) : $v );
	}
	$o_data->end3( 'image acquisition' . ( $flg_multi ? '|#' . ( $n1 + 1 ) : '' ) );
}

$o_data
	->lev2( 'Raw data', $emp_link )
	->end2( 'image acquisition' )
;

//.. Processing

//... method
$o_data->lev3( 'Method', TERM_REC_MET );

//... processing 手法別

foreach ( (array)$json1->processing as $n1 => $c1 ) {
	if ( $n1 == 'method' || $n1 == 'reconstruction' ) continue;
	$o = '';
	foreach ( $c1 as $n2 => $c2 ) {
		if ( $n2 == 'appliedSymmetry' )
			$c2 = _symmetry_text( $c2 );
		$o_data->lev3( $n2, $c2 );
	}
}
$o_data->end3( 'Processing' );
	
//... reconstruction
$x = $json1->processing->reconstruction;
$flg_multi = count( (array)$x ) > 1;
$num = 1;
foreach ( (array)$x as $c1 ) {
	$o = [];
	foreach ( $c1 as $k => $v )
		$o[$k] = $k == 'software'
			? _met_pop_split( $v, 's' )
			: $v
		;
	$o_data->lev2( '3D reconstruction' . ( $flg_multi ? "|#$num" : '' ), $o );
	++ $num;
}

if ( file_exists( _fn( 'fsc_img_s', ID ) ) ) {
	$o_data->lev2(
		TERM_FSC_DESC. _obj('wikipe')->get('Fourier shell correlation')->pop(),
		_img_sl( 'fsc_img_s', 'fsc_img_l' )
	);
}

$o_data->end2( 'Image processing' );

//..  Fitting
$num = 1;
foreach ( (array)$json1->experiment->fitting as $c1 ) {
	$o_data->lev3order([
		'software', 'refProtocol', 'targetCriteria', 'refSpace',
		'details', 'pdbEntryId', 'pdbChainId'
	]);
	foreach( $c1 as $n2=>$c2 ) {
		if ( is_array( $c2 ) )
			$c2 = _imp( $c2 );
		if ( $n2 == 'software' )
			$c2 = _met_pop_split( $c2, 's' );
		$o_data->lev3( $n2, $c2 );
	}
	$o_data->end3( 'Modeling' . "| #$num" );
	++ $num;
}

$o_data
	->lev3( '_', _ent_catalog( _emn_json( 'fit', DID ), [ 'mode'=>'icon' ] ) )
	->end3( 'Output model' )
;

$o_data->end2( 'Atomic model buiding' );

$_simple->time( 'exp.' );

//. function
function _pstable_top( &$map_info, $src, $xyz ) {
	global $map_info;
	return 	TD
		. round( $map_info->{"APIX $xyz"}, 2 ). ' &Aring;/pix.' .BR
		. 'x '. $map_info->$src. ' pix.' . BR
		. '= '. rtrim( $map_info->{"$xyz length"}, '0' ) . ' &Aring;'
	;
}

//.. _pstable_row: pngへのアンカー: jpgイメージ td (プロジェクションなど用)
function _pstable_row( $img, $name, $in1, $in2, $in3, $dn = '' ) {
	global $dn_media;
	$flg_main = ! $dn;
	$ret = TR.TH. _img( "img/$img.gif" )
		. _xbtn( '_slcimg.hide(this)', 'style: display:none' )
		.BR. _l( $name )
	;
	foreach ( [ $in1, $in2, $in3 ] as $s ) {
		$o = '';
		if ( $flg_main ) {//- メインマップ以外？
			$dn = "$dn_media/mapi";

			//- スライスのホバーで線を出す用のIDとclass
			$i = [
				'proj0'  => 'slc_z_',
				'proj2'  => 'slc_y_',
				'proj3'  => 'slc_x_',
				'surf_x' => 'slc_xs',
				'surf_y' => 'slc_ys',
				'surf_z' => 'slc_zs'
			][ $s ] ?: $s;
			$o = "#$i | .slc";
		}
		$ret .= TD . _ab( "$dn/$s.png", _img( $o, "$dn/$s.jpg" ) );
	}
	return $ret;
}

//.. _mol_wt
//- 連想配列の中の分子量関連の表記をまとめる
function _mol_wt( $o ) {
	return [
		'molWtTheo'		=> _mw_calc( $o->molWtTheo ) ,
		'molWtExp' 		=> _mw_calc( $o->molWtExp ) ,
		'molWtMethod'	=> $o->molWtMethod
	];
}

function _mw_calc( $w ) {
	if ( $w == '' ) return;
	$w = preg_replace( '/[^0-9\.]/', '', ( $w ) );
	if ( $w > 1000 ) return ( $w / 1000 ) . 'GDa';
	if ( $w > 1    ) return "$w MDa";
	return ( $w * 1000 ) . " kDa";
}


//.. _emdb_dbid_link: 各種データベースへのリンクを生成して返す
function _emdb_dbid_link( $name, $str ) {
	if ( is_array( $str ) )
		$str = _imp( $str );
	$str = trim( $str );
	$ret = [];

	if ( $name == 'refGo' ) {
		//- GO
		preg_match_all( '/[0-9]+/', $str, $ids );
		foreach ( (array)$ids[0] as $i )
			$ret[] = _obj('dbid')->pop( 'GO', $i );
	} else if ( $name == 'refInterpro' ) {
		//- InterPro
		preg_match_all( '/[0-9]+/', $str, $ids );
		foreach ( (array)$ids[0] as $i )
			$ret[] = _obj('dbid')->pop( 'InterPro', "IPR$i" );
	} else if ( $name == 'refUniProt' ) {
		//- UniProt
		preg_match_all( '/[A-Za-z0-9]+/', $str, $ids );
		foreach ( (array)$ids[0] as $i )
			$ret[] = _obj('dbid')->pop( 'UniProt', $i );
	} else {
		//- それ以外（ないはずだけど）
		$ret = [ $str ];
	}
	return _imp( $ret );
}

//.. _wikipe_em
function _wikipe_em( $key, $val ) {
	return $val
		. (in_array( $key, [ 'electronSource', 'imagingMode', 'illuminationMode' ] )
			? _obj('wikipe')->icon_pop( $val )
			: ''
		)
	;
}

//.. _met_split
function _met_pop_split( $name, $mcateg ) {
	return _met_pop( 
		_reg_rep( $name,[ '/,/' => '@|@', '/ ,?and /' => '@|@' ] ) ,
		$mcateg
	);
}
